// This file is auto-generated by @hey-api/openapi-ts

import { type Options, testControllerTestStudent, testControllerTestAdmin, testControllerTest, usersControllerFindAll, usersControllerCreate, usersControllerCreateStudent, usersControllerCreateStaff, usersControllerInviteUser, usersControllerGetMe, usersControllerUpdateOwnUserDetails, usersControllerUpdateUserStudentDetails, usersControllerUpdateUserStaffDetails, usersControllerRemove, usersControllerFindOne, usersControllerUpdateUserStatus, coursesControllerFindAll, coursesControllerCreate, coursesControllerRemove, coursesControllerFindOne, coursesControllerUpdate, lmsControllerFindAllForStudent, lmsControllerFindAllForMentor, lmsControllerFindAllForAdmin, lmsControllerRemove, lmsControllerFindOne, lmsControllerUpdate, lmsControllerPublish, lmsControllerUnpublish, lmsControllerFindTodos, lmsControllerFindModuleTree, lmsControllerGetModuleProgressOverview, lmsControllerGetModuleProgressDetail, lmsControllerGetDashboardProgress, groupControllerFindAll, groupControllerCreate, groupControllerRemove, groupControllerUpdate, notificationsControllerSubscribe, notificationsControllerGetCount, notificationsControllerFindAll, notificationsControllerFindOne, notificationsControllerMarkAsRead, notificationsControllerMarkAllAsRead, authControllerGetMetadata, authControllerLogin, billingControllerFindAll, billingControllerCreate, billingControllerRemove, billingControllerFindOne, billingControllerUpdate, installmentControllerFindAll, installmentControllerFindOne, paymentsControllerPay, paymentsControllerFindAll, paymentsControllerCreate, paymentsControllerRemove, paymentsControllerFindOne, paymentsControllerUpdate, programControllerFindAll, programControllerCreate, programControllerFindAllMajors, programControllerRemove, programControllerFindOne, programControllerUpdate, chatbotControllerPrompt, appointmentsControllerFindAll, appointmentsControllerCreate, appointmentsControllerFindMentor, appointmentsControllerFindCourses, appointmentsControllerFindBookedRange, appointmentsControllerFindAllBooked, appointmentsControllerRemove, appointmentsControllerFindOne, appointmentsControllerUpdateDetails, appointmentsControllerUpdateStatus, enrollmentControllerFindAllEnrollments, enrollmentControllerCreateEnrollment, enrollmentControllerFindActiveEnrollment, enrollmentControllerRemoveEnrollment, enrollmentControllerFindOneEnrollment, enrollmentControllerUpdateEnrollment, enrollmentControllerUpdateEnrollmentStatus, courseOfferingControllerFindCourseOfferingsByPeriod, courseOfferingControllerCreateCourseOffering, courseOfferingControllerCreateCourseOfferingsByCurriculumId, courseOfferingControllerRemoveCourseOffering, courseOfferingControllerFindOneCourseOffering, courseSectionControllerFindAllCourseSections, courseSectionControllerFindAllCourseSectionsForOffering, courseSectionControllerCreateCourseSection, courseSectionControllerRemoveCourseSection, courseSectionControllerFindOneCourseSection, courseSectionControllerUpdateCourseSection, courseSectionControllerFindOneCourseSectionById, courseEnrollmentControllerGetCourseEnrollments, courseEnrollmentControllerFindAll, courseEnrollmentControllerDropCourseEnrollment, courseEnrollmentControllerCreateCourseEnrollment, courseEnrollmentControllerFinalizeCourseEnrollment, majorControllerFindAll, majorControllerCreate, majorControllerRemove, majorControllerFindOne, majorControllerUpdate, curriculumControllerFindAll, curriculumControllerCreate, curriculumControllerRemove, curriculumControllerFindOne, curriculumControllerUpdate, assignmentControllerUpdate, assignmentControllerSubmit, assignmentControllerFindAllForAdmin, assignmentControllerFindAllForMentor, assignmentControllerFindAllForStudent, assignmentControllerFindOne, assignmentControllerFindOneForStudent, lmsSectionControllerFindAllModuleSections, lmsSectionControllerCreate, lmsSectionControllerRemove, lmsSectionControllerFindOne, lmsSectionControllerUpdate, lmsSectionControllerPublishSection, lmsSectionControllerUnpublishSection, lmsContentControllerFindAll, lmsContentControllerCreate, lmsContentControllerRemove, lmsContentControllerFindOne, lmsContentControllerUpdate, lmsContentControllerPublish, lmsContentControllerUnpublish, lmsContentControllerFindAllContentProgress, lmsContentControllerCreateContentProgress, submissionControllerFindAssignmentSubmissionsForAssignment, submissionControllerSubmitAssignment, submissionControllerFindOne, submissionControllerGrade, submissionControllerFindAssignmentSubmissionsOfStudent, submissionControllerFindAssignmentSubmissionsOfStudentForAssignment, gradingControllerGetStudentGradebook, gradingControllerGetMentorGradebook, gradingControllerGetAdminGradebook, gradingControllerGradeAssignmentSubmission, gradingControllerUpdateGradeRecord, swaggerControllerDownloadAllSpecs, pricingControllerFindAll, pricingControllerCreate, pricingControllerRemove, pricingControllerFindOne, pricingControllerUpdate, pricingGroupControllerFindAll, pricingGroupControllerCreate, pricingGroupControllerRemove, pricingGroupControllerFindOne, pricingGroupControllerUpdate, transcriptControllerFindAll, transcriptControllerUpsert, transcriptControllerRemove, transcriptControllerFindOneTranscript, transcriptControllerUpdate } from '../sdk.gen';
import { queryOptions, infiniteQueryOptions, type InfiniteData, type DefaultError, type UseMutationOptions } from '@tanstack/react-query';
import type { TestControllerTestStudentData, TestControllerTestAdminData, TestControllerTestData, TestControllerTestResponse, UsersControllerFindAllData, UsersControllerFindAllError, UsersControllerFindAllResponse, UsersControllerCreateData, UsersControllerCreateError, UsersControllerCreateResponse, UsersControllerCreateStudentData, UsersControllerCreateStudentError, UsersControllerCreateStudentResponse, UsersControllerCreateStaffData, UsersControllerCreateStaffError, UsersControllerCreateStaffResponse, UsersControllerInviteUserData, UsersControllerInviteUserError, UsersControllerInviteUserResponse, UsersControllerGetMeData, UsersControllerUpdateOwnUserDetailsData, UsersControllerUpdateOwnUserDetailsError, UsersControllerUpdateOwnUserDetailsResponse, UsersControllerUpdateUserStudentDetailsData, UsersControllerUpdateUserStudentDetailsError, UsersControllerUpdateUserStudentDetailsResponse, UsersControllerUpdateUserStaffDetailsData, UsersControllerUpdateUserStaffDetailsError, UsersControllerUpdateUserStaffDetailsResponse, UsersControllerRemoveData, UsersControllerRemoveError, UsersControllerRemoveResponse, UsersControllerFindOneData, UsersControllerUpdateUserStatusData, UsersControllerUpdateUserStatusError, UsersControllerUpdateUserStatusResponse, CoursesControllerFindAllData, CoursesControllerFindAllError, CoursesControllerFindAllResponse, CoursesControllerCreateData, CoursesControllerCreateError, CoursesControllerCreateResponse, CoursesControllerRemoveData, CoursesControllerRemoveError, CoursesControllerRemoveResponse, CoursesControllerFindOneData, CoursesControllerUpdateData, CoursesControllerUpdateError, CoursesControllerUpdateResponse, LmsControllerFindAllForStudentData, LmsControllerFindAllForStudentError, LmsControllerFindAllForStudentResponse, LmsControllerFindAllForMentorData, LmsControllerFindAllForMentorError, LmsControllerFindAllForMentorResponse, LmsControllerFindAllForAdminData, LmsControllerFindAllForAdminError, LmsControllerFindAllForAdminResponse, LmsControllerRemoveData, LmsControllerRemoveError, LmsControllerRemoveResponse, LmsControllerFindOneData, LmsControllerUpdateData, LmsControllerUpdateError, LmsControllerUpdateResponse, LmsControllerPublishData, LmsControllerPublishError, LmsControllerUnpublishData, LmsControllerUnpublishError, LmsControllerFindTodosData, LmsControllerFindTodosError, LmsControllerFindTodosResponse, LmsControllerFindModuleTreeData, LmsControllerGetModuleProgressOverviewData, LmsControllerGetModuleProgressDetailData, LmsControllerGetDashboardProgressData, GroupControllerFindAllData, GroupControllerCreateData, GroupControllerCreateError, GroupControllerCreateResponse, GroupControllerRemoveData, GroupControllerRemoveError, GroupControllerUpdateData, GroupControllerUpdateError, GroupControllerUpdateResponse, NotificationsControllerSubscribeData, NotificationsControllerGetCountData, NotificationsControllerFindAllData, NotificationsControllerFindAllResponse, NotificationsControllerFindOneData, NotificationsControllerMarkAsReadData, NotificationsControllerMarkAllAsReadData, AuthControllerGetMetadataData, AuthControllerLoginData, AuthControllerLoginError, AuthControllerLoginResponse, BillingControllerFindAllData, BillingControllerFindAllError, BillingControllerFindAllResponse, BillingControllerCreateData, BillingControllerCreateError, BillingControllerCreateResponse, BillingControllerRemoveData, BillingControllerRemoveError, BillingControllerFindOneData, BillingControllerUpdateData, BillingControllerUpdateError, BillingControllerUpdateResponse, InstallmentControllerFindAllData, InstallmentControllerFindOneData, PaymentsControllerPayData, PaymentsControllerPayError, PaymentsControllerPayResponse, PaymentsControllerFindAllData, PaymentsControllerCreateData, PaymentsControllerCreateError, PaymentsControllerCreateResponse, PaymentsControllerRemoveData, PaymentsControllerRemoveError, PaymentsControllerFindOneData, PaymentsControllerUpdateData, PaymentsControllerUpdateError, PaymentsControllerUpdateResponse, ProgramControllerFindAllData, ProgramControllerFindAllError, ProgramControllerFindAllResponse, ProgramControllerCreateData, ProgramControllerCreateError, ProgramControllerCreateResponse, ProgramControllerFindAllMajorsData, ProgramControllerFindAllMajorsError, ProgramControllerFindAllMajorsResponse, ProgramControllerRemoveData, ProgramControllerRemoveError, ProgramControllerRemoveResponse, ProgramControllerFindOneData, ProgramControllerUpdateData, ProgramControllerUpdateError, ProgramControllerUpdateResponse, ChatbotControllerPromptData, ChatbotControllerPromptError, ChatbotControllerPromptResponse, AppointmentsControllerFindAllData, AppointmentsControllerFindAllError, AppointmentsControllerFindAllResponse, AppointmentsControllerCreateData, AppointmentsControllerCreateError, AppointmentsControllerCreateResponse, AppointmentsControllerFindMentorData, AppointmentsControllerFindMentorResponse, AppointmentsControllerFindCoursesData, AppointmentsControllerFindBookedRangeData, AppointmentsControllerFindAllBookedData, AppointmentsControllerRemoveData, AppointmentsControllerRemoveError, AppointmentsControllerFindOneData, AppointmentsControllerUpdateDetailsData, AppointmentsControllerUpdateDetailsError, AppointmentsControllerUpdateDetailsResponse, AppointmentsControllerUpdateStatusData, AppointmentsControllerUpdateStatusError, AppointmentsControllerUpdateStatusResponse, EnrollmentControllerFindAllEnrollmentsData, EnrollmentControllerFindAllEnrollmentsError, EnrollmentControllerFindAllEnrollmentsResponse, EnrollmentControllerCreateEnrollmentData, EnrollmentControllerCreateEnrollmentError, EnrollmentControllerCreateEnrollmentResponse, EnrollmentControllerFindActiveEnrollmentData, EnrollmentControllerRemoveEnrollmentData, EnrollmentControllerRemoveEnrollmentError, EnrollmentControllerRemoveEnrollmentResponse, EnrollmentControllerFindOneEnrollmentData, EnrollmentControllerUpdateEnrollmentData, EnrollmentControllerUpdateEnrollmentError, EnrollmentControllerUpdateEnrollmentResponse, EnrollmentControllerUpdateEnrollmentStatusData, EnrollmentControllerUpdateEnrollmentStatusError, EnrollmentControllerUpdateEnrollmentStatusResponse, CourseOfferingControllerFindCourseOfferingsByPeriodData, CourseOfferingControllerFindCourseOfferingsByPeriodResponse, CourseOfferingControllerCreateCourseOfferingData, CourseOfferingControllerCreateCourseOfferingError, CourseOfferingControllerCreateCourseOfferingResponse, CourseOfferingControllerCreateCourseOfferingsByCurriculumIdData, CourseOfferingControllerCreateCourseOfferingsByCurriculumIdError, CourseOfferingControllerCreateCourseOfferingsByCurriculumIdResponse, CourseOfferingControllerRemoveCourseOfferingData, CourseOfferingControllerRemoveCourseOfferingError, CourseOfferingControllerRemoveCourseOfferingResponse, CourseOfferingControllerFindOneCourseOfferingData, CourseSectionControllerFindAllCourseSectionsData, CourseSectionControllerFindAllCourseSectionsError, CourseSectionControllerFindAllCourseSectionsResponse, CourseSectionControllerFindAllCourseSectionsForOfferingData, CourseSectionControllerFindAllCourseSectionsForOfferingError, CourseSectionControllerFindAllCourseSectionsForOfferingResponse, CourseSectionControllerCreateCourseSectionData, CourseSectionControllerCreateCourseSectionError, CourseSectionControllerCreateCourseSectionResponse, CourseSectionControllerRemoveCourseSectionData, CourseSectionControllerRemoveCourseSectionError, CourseSectionControllerRemoveCourseSectionResponse, CourseSectionControllerFindOneCourseSectionData, CourseSectionControllerUpdateCourseSectionData, CourseSectionControllerUpdateCourseSectionError, CourseSectionControllerUpdateCourseSectionResponse, CourseSectionControllerFindOneCourseSectionByIdData, CourseEnrollmentControllerGetCourseEnrollmentsData, CourseEnrollmentControllerGetCourseEnrollmentsError, CourseEnrollmentControllerGetCourseEnrollmentsResponse, CourseEnrollmentControllerFindAllData, CourseEnrollmentControllerFindAllError, CourseEnrollmentControllerFindAllResponse, CourseEnrollmentControllerDropCourseEnrollmentData, CourseEnrollmentControllerDropCourseEnrollmentError, CourseEnrollmentControllerDropCourseEnrollmentResponse, CourseEnrollmentControllerCreateCourseEnrollmentData, CourseEnrollmentControllerCreateCourseEnrollmentError, CourseEnrollmentControllerCreateCourseEnrollmentResponse, CourseEnrollmentControllerFinalizeCourseEnrollmentData, CourseEnrollmentControllerFinalizeCourseEnrollmentError, CourseEnrollmentControllerFinalizeCourseEnrollmentResponse, MajorControllerFindAllData, MajorControllerFindAllError, MajorControllerFindAllResponse, MajorControllerCreateData, MajorControllerCreateError, MajorControllerCreateResponse, MajorControllerRemoveData, MajorControllerRemoveError, MajorControllerRemoveResponse, MajorControllerFindOneData, MajorControllerUpdateData, MajorControllerUpdateError, MajorControllerUpdateResponse, CurriculumControllerFindAllData, CurriculumControllerCreateData, CurriculumControllerCreateError, CurriculumControllerCreateResponse, CurriculumControllerRemoveData, CurriculumControllerRemoveError, CurriculumControllerRemoveResponse, CurriculumControllerFindOneData, CurriculumControllerUpdateData, CurriculumControllerUpdateError, CurriculumControllerUpdateResponse, AssignmentControllerUpdateData, AssignmentControllerUpdateError, AssignmentControllerSubmitData, AssignmentControllerSubmitError, AssignmentControllerFindAllForAdminData, AssignmentControllerFindAllForAdminError, AssignmentControllerFindAllForAdminResponse, AssignmentControllerFindAllForMentorData, AssignmentControllerFindAllForMentorError, AssignmentControllerFindAllForMentorResponse, AssignmentControllerFindAllForStudentData, AssignmentControllerFindAllForStudentError, AssignmentControllerFindAllForStudentResponse, AssignmentControllerFindOneData, AssignmentControllerFindOneForStudentData, LmsSectionControllerFindAllModuleSectionsData, LmsSectionControllerCreateData, LmsSectionControllerCreateError, LmsSectionControllerCreateResponse, LmsSectionControllerRemoveData, LmsSectionControllerRemoveError, LmsSectionControllerFindOneData, LmsSectionControllerUpdateData, LmsSectionControllerUpdateError, LmsSectionControllerUpdateResponse, LmsSectionControllerPublishSectionData, LmsSectionControllerPublishSectionError, LmsSectionControllerUnpublishSectionData, LmsSectionControllerUnpublishSectionError, LmsContentControllerFindAllData, LmsContentControllerFindAllError, LmsContentControllerFindAllResponse, LmsContentControllerCreateData, LmsContentControllerCreateError, LmsContentControllerCreateResponse, LmsContentControllerRemoveData, LmsContentControllerRemoveError, LmsContentControllerRemoveResponse, LmsContentControllerFindOneData, LmsContentControllerUpdateData, LmsContentControllerUpdateError, LmsContentControllerUpdateResponse, LmsContentControllerPublishData, LmsContentControllerPublishError, LmsContentControllerPublishResponse, LmsContentControllerUnpublishData, LmsContentControllerUnpublishError, LmsContentControllerUnpublishResponse, LmsContentControllerFindAllContentProgressData, LmsContentControllerCreateContentProgressData, LmsContentControllerCreateContentProgressError, LmsContentControllerCreateContentProgressResponse, SubmissionControllerFindAssignmentSubmissionsForAssignmentData, SubmissionControllerSubmitAssignmentData, SubmissionControllerSubmitAssignmentError, SubmissionControllerSubmitAssignmentResponse, SubmissionControllerFindOneData, SubmissionControllerGradeData, SubmissionControllerGradeError, SubmissionControllerGradeResponse, SubmissionControllerFindAssignmentSubmissionsOfStudentData, SubmissionControllerFindAssignmentSubmissionsOfStudentForAssignmentData, GradingControllerGetStudentGradebookData, GradingControllerGetStudentGradebookError, GradingControllerGetStudentGradebookResponse, GradingControllerGetMentorGradebookData, GradingControllerGetMentorGradebookError, GradingControllerGetMentorGradebookResponse, GradingControllerGetAdminGradebookData, GradingControllerGetAdminGradebookError, GradingControllerGetAdminGradebookResponse, GradingControllerGradeAssignmentSubmissionData, GradingControllerGradeAssignmentSubmissionError, GradingControllerGradeAssignmentSubmissionResponse, GradingControllerUpdateGradeRecordData, GradingControllerUpdateGradeRecordError, GradingControllerUpdateGradeRecordResponse, SwaggerControllerDownloadAllSpecsData, PricingControllerFindAllData, PricingControllerFindAllError, PricingControllerFindAllResponse, PricingControllerCreateData, PricingControllerCreateError, PricingControllerCreateResponse, PricingControllerRemoveData, PricingControllerRemoveError, PricingControllerFindOneData, PricingControllerUpdateData, PricingControllerUpdateError, PricingControllerUpdateResponse, PricingGroupControllerFindAllData, PricingGroupControllerFindAllError, PricingGroupControllerFindAllResponse, PricingGroupControllerCreateData, PricingGroupControllerCreateError, PricingGroupControllerCreateResponse, PricingGroupControllerRemoveData, PricingGroupControllerRemoveError, PricingGroupControllerFindOneData, PricingGroupControllerUpdateData, PricingGroupControllerUpdateError, PricingGroupControllerUpdateResponse, TranscriptControllerFindAllData, TranscriptControllerUpsertData, TranscriptControllerUpsertError, TranscriptControllerUpsertResponse, TranscriptControllerRemoveData, TranscriptControllerRemoveError, TranscriptControllerFindOneTranscriptData, TranscriptControllerUpdateData, TranscriptControllerUpdateError, TranscriptControllerUpdateResponse } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const testControllerTestStudentQueryKey = (options?: Options<TestControllerTestStudentData>) => createQueryKey('testControllerTestStudent', options);

export const testControllerTestStudentOptions = (options?: Options<TestControllerTestStudentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testControllerTestStudent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testControllerTestStudentQueryKey(options)
    });
};

export const testControllerTestAdminQueryKey = (options?: Options<TestControllerTestAdminData>) => createQueryKey('testControllerTestAdmin', options);

export const testControllerTestAdminOptions = (options?: Options<TestControllerTestAdminData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testControllerTestAdmin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testControllerTestAdminQueryKey(options)
    });
};

export const testControllerTestQueryKey = (options: Options<TestControllerTestData>) => createQueryKey('testControllerTest', options);

/**
 * Logging Test
 * Test the logging & prisma error handling functionality
 */
export const testControllerTestOptions = (options: Options<TestControllerTestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testControllerTest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testControllerTestQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const testControllerTestInfiniteQueryKey = (options: Options<TestControllerTestData>): QueryKey<Options<TestControllerTestData>> => createQueryKey('testControllerTest', options, true);

/**
 * Logging Test
 * Test the logging & prisma error handling functionality
 */
export const testControllerTestInfiniteOptions = (options: Options<TestControllerTestData>) => {
    return infiniteQueryOptions<TestControllerTestResponse, DefaultError, InfiniteData<TestControllerTestResponse>, QueryKey<Options<TestControllerTestData>>, number | Pick<QueryKey<Options<TestControllerTestData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<TestControllerTestData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await testControllerTest({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testControllerTestInfiniteQueryKey(options)
    });
};

/**
 * Logging Test
 * Test the logging & prisma error handling functionality
 */
export const testControllerTestMutation = (options?: Partial<Options<TestControllerTestData>>): UseMutationOptions<TestControllerTestResponse, DefaultError, Options<TestControllerTestData>> => {
    const mutationOptions: UseMutationOptions<TestControllerTestResponse, DefaultError, Options<TestControllerTestData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await testControllerTest({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerFindAllQueryKey = (options?: Options<UsersControllerFindAllData>) => createQueryKey('usersControllerFindAll', options);

/**
 * Get users
 * Retrieves a paginated list of users based on the provided filter parameters.
 * - **Access: ** Requires `ADMIN` role.
 * - **Filtering & Pagination: ** Uses the `FilterUserDto` to define query parameters such as search terms, sorting, and page size.
 */
export const usersControllerFindAllOptions = (options?: Options<UsersControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerFindAllQueryKey(options)
    });
};

export const usersControllerFindAllInfiniteQueryKey = (options?: Options<UsersControllerFindAllData>): QueryKey<Options<UsersControllerFindAllData>> => createQueryKey('usersControllerFindAll', options, true);

/**
 * Get users
 * Retrieves a paginated list of users based on the provided filter parameters.
 * - **Access: ** Requires `ADMIN` role.
 * - **Filtering & Pagination: ** Uses the `FilterUserDto` to define query parameters such as search terms, sorting, and page size.
 */
export const usersControllerFindAllInfiniteOptions = (options?: Options<UsersControllerFindAllData>) => {
    return infiniteQueryOptions<UsersControllerFindAllResponse, UsersControllerFindAllError, InfiniteData<UsersControllerFindAllResponse>, QueryKey<Options<UsersControllerFindAllData>>, number | Pick<QueryKey<Options<UsersControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<UsersControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await usersControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerFindAllInfiniteQueryKey(options)
    });
};

export const usersControllerCreateQueryKey = (options: Options<UsersControllerCreateData>) => createQueryKey('usersControllerCreate', options);

/**
 * Create a new user
 * This operation creates both a user and a supabase auth account
 */
export const usersControllerCreateOptions = (options: Options<UsersControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerCreateQueryKey(options)
    });
};

/**
 * Create a new user
 * This operation creates both a user and a supabase auth account
 */
export const usersControllerCreateMutation = (options?: Partial<Options<UsersControllerCreateData>>): UseMutationOptions<UsersControllerCreateResponse, UsersControllerCreateError, Options<UsersControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerCreateResponse, UsersControllerCreateError, Options<UsersControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerCreateStudentQueryKey = (options: Options<UsersControllerCreateStudentData>) => createQueryKey('usersControllerCreateStudent', options);

/**
 * Create a new student user
 * This operation creates both a user and a supabase auth account.
 * It also has additional properties for student-specific details.
 */
export const usersControllerCreateStudentOptions = (options: Options<UsersControllerCreateStudentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerCreateStudent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerCreateStudentQueryKey(options)
    });
};

/**
 * Create a new student user
 * This operation creates both a user and a supabase auth account.
 * It also has additional properties for student-specific details.
 */
export const usersControllerCreateStudentMutation = (options?: Partial<Options<UsersControllerCreateStudentData>>): UseMutationOptions<UsersControllerCreateStudentResponse, UsersControllerCreateStudentError, Options<UsersControllerCreateStudentData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerCreateStudentResponse, UsersControllerCreateStudentError, Options<UsersControllerCreateStudentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerCreateStudent({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerCreateStaffQueryKey = (options: Options<UsersControllerCreateStaffData>) => createQueryKey('usersControllerCreateStaff', options);

/**
 * Create a new staff user
 * This operation creates both a user and a supabase auth account.
 * It also has additional properties for staff-specific details.
 */
export const usersControllerCreateStaffOptions = (options: Options<UsersControllerCreateStaffData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerCreateStaff({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerCreateStaffQueryKey(options)
    });
};

/**
 * Create a new staff user
 * This operation creates both a user and a supabase auth account.
 * It also has additional properties for staff-specific details.
 */
export const usersControllerCreateStaffMutation = (options?: Partial<Options<UsersControllerCreateStaffData>>): UseMutationOptions<UsersControllerCreateStaffResponse, UsersControllerCreateStaffError, Options<UsersControllerCreateStaffData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerCreateStaffResponse, UsersControllerCreateStaffError, Options<UsersControllerCreateStaffData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerCreateStaff({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerInviteUserQueryKey = (options: Options<UsersControllerInviteUserData>) => createQueryKey('usersControllerInviteUser', options);

/**
 * Invite a new user
 * This operation creates both a user and a supabase auth account
 */
export const usersControllerInviteUserOptions = (options: Options<UsersControllerInviteUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerInviteUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerInviteUserQueryKey(options)
    });
};

/**
 * Invite a new user
 * This operation creates both a user and a supabase auth account
 */
export const usersControllerInviteUserMutation = (options?: Partial<Options<UsersControllerInviteUserData>>): UseMutationOptions<UsersControllerInviteUserResponse, UsersControllerInviteUserError, Options<UsersControllerInviteUserData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerInviteUserResponse, UsersControllerInviteUserError, Options<UsersControllerInviteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerInviteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerGetMeQueryKey = (options?: Options<UsersControllerGetMeData>) => createQueryKey('usersControllerGetMe', options);

/**
 * Get the currently authenticated user
 * This endpoint returns the full profile of the currently authenticated user.
 * The structure of the returned object depends on the user's role:
 *
 * - `UserStudentDetailsDto` for users with the `student` role
 * - `UserStaffDetailsDto` for users with the `mentor` or `admin` role
 */
export const usersControllerGetMeOptions = (options?: Options<UsersControllerGetMeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerGetMe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerGetMeQueryKey(options)
    });
};

/**
 * Update personal details
 * This operation updates the user details in the database
 */
export const usersControllerUpdateOwnUserDetailsMutation = (options?: Partial<Options<UsersControllerUpdateOwnUserDetailsData>>): UseMutationOptions<UsersControllerUpdateOwnUserDetailsResponse, UsersControllerUpdateOwnUserDetailsError, Options<UsersControllerUpdateOwnUserDetailsData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerUpdateOwnUserDetailsResponse, UsersControllerUpdateOwnUserDetailsError, Options<UsersControllerUpdateOwnUserDetailsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerUpdateOwnUserDetails({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update student user details (Admin only)
 * This operation updates the user details in the database.
 * The user should have a student role.
 */
export const usersControllerUpdateUserStudentDetailsMutation = (options?: Partial<Options<UsersControllerUpdateUserStudentDetailsData>>): UseMutationOptions<UsersControllerUpdateUserStudentDetailsResponse, UsersControllerUpdateUserStudentDetailsError, Options<UsersControllerUpdateUserStudentDetailsData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerUpdateUserStudentDetailsResponse, UsersControllerUpdateUserStudentDetailsError, Options<UsersControllerUpdateUserStudentDetailsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerUpdateUserStudentDetails({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update staff user details (Admin only)
 * This operation updates the user details in the database.
 * The user should have a mentor or admin role.
 */
export const usersControllerUpdateUserStaffDetailsMutation = (options?: Partial<Options<UsersControllerUpdateUserStaffDetailsData>>): UseMutationOptions<UsersControllerUpdateUserStaffDetailsResponse, UsersControllerUpdateUserStaffDetailsError, Options<UsersControllerUpdateUserStaffDetailsData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerUpdateUserStaffDetailsResponse, UsersControllerUpdateUserStaffDetailsError, Options<UsersControllerUpdateUserStaffDetailsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerUpdateUserStaffDetails({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Deletes a user (soft and hard delete)
 * This endpoint performs either a soft delete or a permanent deletion of a user depending on the current state of the user or the query parameter provided:
 *
 * - If `directDelete` is true, the user is **permanently deleted** without checking if they are already softly deleted.
 * - If `directDelete` is not provided or false:
 * - If the user is not yet softly deleted (`deletedAt` is null), a **soft delete** is performed by setting the `deletedAt` timestamp.
 * - If the user is already softly deleted, a **permanent delete** is executed.
 *
 * All the user details and the supabase auth account will be deleted from the cloud on hard delete
 *
 * Use this endpoint to manage user deletion workflows flexibly through a single API.
 */
export const usersControllerRemoveMutation = (options?: Partial<Options<UsersControllerRemoveData>>): UseMutationOptions<UsersControllerRemoveResponse, UsersControllerRemoveError, Options<UsersControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerRemoveResponse, UsersControllerRemoveError, Options<UsersControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerFindOneQueryKey = (options: Options<UsersControllerFindOneData>) => createQueryKey('usersControllerFindOne', options);

/**
 * Get user by id
 * Retrieves a specific user by their unique identifier.
 * - **Validation: ** Ensures the provided `id` is a valid identifier format.
 * - **Not Found Handling: ** Throws an error if no matching user is found.
 */
export const usersControllerFindOneOptions = (options: Options<UsersControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerFindOneQueryKey(options)
    });
};

/**
 * Updates the status of a user (enable/disable).
 * This endpoint toggles the user's status between active and disabled
 * by updating the `disabledAt` field. The change is also reflected in
 * the authentication provider's metadata.
 */
export const usersControllerUpdateUserStatusMutation = (options?: Partial<Options<UsersControllerUpdateUserStatusData>>): UseMutationOptions<UsersControllerUpdateUserStatusResponse, UsersControllerUpdateUserStatusError, Options<UsersControllerUpdateUserStatusData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerUpdateUserStatusResponse, UsersControllerUpdateUserStatusError, Options<UsersControllerUpdateUserStatusData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerUpdateUserStatus({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const coursesControllerFindAllQueryKey = (options?: Options<CoursesControllerFindAllData>) => createQueryKey('coursesControllerFindAll', options);

/**
 * Retrive all courses
 * Retrives a paginated list of courses based on the provided filters.
 * Requires `ADMIN` role.
 */
export const coursesControllerFindAllOptions = (options?: Options<CoursesControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await coursesControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: coursesControllerFindAllQueryKey(options)
    });
};

export const coursesControllerFindAllInfiniteQueryKey = (options?: Options<CoursesControllerFindAllData>): QueryKey<Options<CoursesControllerFindAllData>> => createQueryKey('coursesControllerFindAll', options, true);

/**
 * Retrive all courses
 * Retrives a paginated list of courses based on the provided filters.
 * Requires `ADMIN` role.
 */
export const coursesControllerFindAllInfiniteOptions = (options?: Options<CoursesControllerFindAllData>) => {
    return infiniteQueryOptions<CoursesControllerFindAllResponse, CoursesControllerFindAllError, InfiniteData<CoursesControllerFindAllResponse>, QueryKey<Options<CoursesControllerFindAllData>>, number | Pick<QueryKey<Options<CoursesControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<CoursesControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await coursesControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: coursesControllerFindAllInfiniteQueryKey(options)
    });
};

export const coursesControllerCreateQueryKey = (options: Options<CoursesControllerCreateData>) => createQueryKey('coursesControllerCreate', options);

/**
 * Creates a course
 * This operations creates a new course.
 * Requires `ADMIN` role.
 */
export const coursesControllerCreateOptions = (options: Options<CoursesControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await coursesControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: coursesControllerCreateQueryKey(options)
    });
};

/**
 * Creates a course
 * This operations creates a new course.
 * Requires `ADMIN` role.
 */
export const coursesControllerCreateMutation = (options?: Partial<Options<CoursesControllerCreateData>>): UseMutationOptions<CoursesControllerCreateResponse, CoursesControllerCreateError, Options<CoursesControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<CoursesControllerCreateResponse, CoursesControllerCreateError, Options<CoursesControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await coursesControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a course
 * This operation permanently deletes a course from the system.
 * Requires `ADMIN` role.
 */
export const coursesControllerRemoveMutation = (options?: Partial<Options<CoursesControllerRemoveData>>): UseMutationOptions<CoursesControllerRemoveResponse, CoursesControllerRemoveError, Options<CoursesControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<CoursesControllerRemoveResponse, CoursesControllerRemoveError, Options<CoursesControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await coursesControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const coursesControllerFindOneQueryKey = (options: Options<CoursesControllerFindOneData>) => createQueryKey('coursesControllerFindOne', options);

/**
 * Retrieve a specific course by ID
 * Requires `ADMIN` role.
 */
export const coursesControllerFindOneOptions = (options: Options<CoursesControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await coursesControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: coursesControllerFindOneQueryKey(options)
    });
};

/**
 * Update a course
 * This operation updates the details of an existing course.
 * Requires `ADMIN` role.
 */
export const coursesControllerUpdateMutation = (options?: Partial<Options<CoursesControllerUpdateData>>): UseMutationOptions<CoursesControllerUpdateResponse, CoursesControllerUpdateError, Options<CoursesControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<CoursesControllerUpdateResponse, CoursesControllerUpdateError, Options<CoursesControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await coursesControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lmsControllerFindAllForStudentQueryKey = (options?: Options<LmsControllerFindAllForStudentData>) => createQueryKey('lmsControllerFindAllForStudent', options);

/**
 * Retrieve all modules for students
 * Returns a paginated list of modules for the current student user.
 * Only modules from courses the student is enrolled in are included.
 * Requires `STUDENT` role.
 */
export const lmsControllerFindAllForStudentOptions = (options?: Options<LmsControllerFindAllForStudentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsControllerFindAllForStudent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerFindAllForStudentQueryKey(options)
    });
};

export const lmsControllerFindAllForStudentInfiniteQueryKey = (options?: Options<LmsControllerFindAllForStudentData>): QueryKey<Options<LmsControllerFindAllForStudentData>> => createQueryKey('lmsControllerFindAllForStudent', options, true);

/**
 * Retrieve all modules for students
 * Returns a paginated list of modules for the current student user.
 * Only modules from courses the student is enrolled in are included.
 * Requires `STUDENT` role.
 */
export const lmsControllerFindAllForStudentInfiniteOptions = (options?: Options<LmsControllerFindAllForStudentData>) => {
    return infiniteQueryOptions<LmsControllerFindAllForStudentResponse, LmsControllerFindAllForStudentError, InfiniteData<LmsControllerFindAllForStudentResponse>, QueryKey<Options<LmsControllerFindAllForStudentData>>, number | Pick<QueryKey<Options<LmsControllerFindAllForStudentData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<LmsControllerFindAllForStudentData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await lmsControllerFindAllForStudent({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerFindAllForStudentInfiniteQueryKey(options)
    });
};

export const lmsControllerFindAllForMentorQueryKey = (options?: Options<LmsControllerFindAllForMentorData>) => createQueryKey('lmsControllerFindAllForMentor', options);

/**
 * Retrieve all modules for mentors
 * Returns a paginated list of modules for the current mentor user.
 * Only modules from courses the mentor is assigned to are included.
 * Requires `MENTOR` role.
 */
export const lmsControllerFindAllForMentorOptions = (options?: Options<LmsControllerFindAllForMentorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsControllerFindAllForMentor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerFindAllForMentorQueryKey(options)
    });
};

export const lmsControllerFindAllForMentorInfiniteQueryKey = (options?: Options<LmsControllerFindAllForMentorData>): QueryKey<Options<LmsControllerFindAllForMentorData>> => createQueryKey('lmsControllerFindAllForMentor', options, true);

/**
 * Retrieve all modules for mentors
 * Returns a paginated list of modules for the current mentor user.
 * Only modules from courses the mentor is assigned to are included.
 * Requires `MENTOR` role.
 */
export const lmsControllerFindAllForMentorInfiniteOptions = (options?: Options<LmsControllerFindAllForMentorData>) => {
    return infiniteQueryOptions<LmsControllerFindAllForMentorResponse, LmsControllerFindAllForMentorError, InfiniteData<LmsControllerFindAllForMentorResponse>, QueryKey<Options<LmsControllerFindAllForMentorData>>, number | Pick<QueryKey<Options<LmsControllerFindAllForMentorData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<LmsControllerFindAllForMentorData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await lmsControllerFindAllForMentor({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerFindAllForMentorInfiniteQueryKey(options)
    });
};

export const lmsControllerFindAllForAdminQueryKey = (options?: Options<LmsControllerFindAllForAdminData>) => createQueryKey('lmsControllerFindAllForAdmin', options);

/**
 * Retrieve all modules for admins
 * Returns a paginated list of all modules across all courses.
 * Requires `ADMIN` role.
 */
export const lmsControllerFindAllForAdminOptions = (options?: Options<LmsControllerFindAllForAdminData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsControllerFindAllForAdmin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerFindAllForAdminQueryKey(options)
    });
};

export const lmsControllerFindAllForAdminInfiniteQueryKey = (options?: Options<LmsControllerFindAllForAdminData>): QueryKey<Options<LmsControllerFindAllForAdminData>> => createQueryKey('lmsControllerFindAllForAdmin', options, true);

/**
 * Retrieve all modules for admins
 * Returns a paginated list of all modules across all courses.
 * Requires `ADMIN` role.
 */
export const lmsControllerFindAllForAdminInfiniteOptions = (options?: Options<LmsControllerFindAllForAdminData>) => {
    return infiniteQueryOptions<LmsControllerFindAllForAdminResponse, LmsControllerFindAllForAdminError, InfiniteData<LmsControllerFindAllForAdminResponse>, QueryKey<Options<LmsControllerFindAllForAdminData>>, number | Pick<QueryKey<Options<LmsControllerFindAllForAdminData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<LmsControllerFindAllForAdminData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await lmsControllerFindAllForAdmin({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerFindAllForAdminInfiniteQueryKey(options)
    });
};

/**
 * Deletes a module
 * This operation deletes a module from the system.
 * Requires `ADMIN` role.
 */
export const lmsControllerRemoveMutation = (options?: Partial<Options<LmsControllerRemoveData>>): UseMutationOptions<LmsControllerRemoveResponse, LmsControllerRemoveError, Options<LmsControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<LmsControllerRemoveResponse, LmsControllerRemoveError, Options<LmsControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lmsControllerFindOneQueryKey = (options: Options<LmsControllerFindOneData>) => createQueryKey('lmsControllerFindOne', options);

/**
 * Retrieve a single module by id
 * Response includes the module with its course offering and filtered course sections
 * appropriate for the requesting user. Requires `STUDENT`, `MENTOR`, or `ADMIN` role.
 */
export const lmsControllerFindOneOptions = (options: Options<LmsControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerFindOneQueryKey(options)
    });
};

/**
 * Updates a module
 * This operation updates the details of an existing module.
 * Requires `ADMIN` role.
 */
export const lmsControllerUpdateMutation = (options?: Partial<Options<LmsControllerUpdateData>>): UseMutationOptions<LmsControllerUpdateResponse, LmsControllerUpdateError, Options<LmsControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<LmsControllerUpdateResponse, LmsControllerUpdateError, Options<LmsControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lmsControllerPublishQueryKey = (options: Options<LmsControllerPublishData>) => createQueryKey('lmsControllerPublish', options);

/**
 * Publishes a module
 * Publishes a module with an optional date.
 * Requires `ADMIN` role.
 */
export const lmsControllerPublishOptions = (options: Options<LmsControllerPublishData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsControllerPublish({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerPublishQueryKey(options)
    });
};

/**
 * Publishes a module
 * Publishes a module with an optional date.
 * Requires `ADMIN` role.
 */
export const lmsControllerPublishMutation = (options?: Partial<Options<LmsControllerPublishData>>): UseMutationOptions<unknown, LmsControllerPublishError, Options<LmsControllerPublishData>> => {
    const mutationOptions: UseMutationOptions<unknown, LmsControllerPublishError, Options<LmsControllerPublishData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsControllerPublish({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lmsControllerUnpublishQueryKey = (options: Options<LmsControllerUnpublishData>) => createQueryKey('lmsControllerUnpublish', options);

/**
 * Unpublishes a module
 * Unpublishes a module.
 * Requires `ADMIN` role.
 */
export const lmsControllerUnpublishOptions = (options: Options<LmsControllerUnpublishData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsControllerUnpublish({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerUnpublishQueryKey(options)
    });
};

/**
 * Unpublishes a module
 * Unpublishes a module.
 * Requires `ADMIN` role.
 */
export const lmsControllerUnpublishMutation = (options?: Partial<Options<LmsControllerUnpublishData>>): UseMutationOptions<unknown, LmsControllerUnpublishError, Options<LmsControllerUnpublishData>> => {
    const mutationOptions: UseMutationOptions<unknown, LmsControllerUnpublishError, Options<LmsControllerUnpublishData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsControllerUnpublish({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lmsControllerFindTodosQueryKey = (options?: Options<LmsControllerFindTodosData>) => createQueryKey('lmsControllerFindTodos', options);

/**
 * Retrieve multiple todos
 * Requires `STUDENT` role.
 */
export const lmsControllerFindTodosOptions = (options?: Options<LmsControllerFindTodosData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsControllerFindTodos({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerFindTodosQueryKey(options)
    });
};

export const lmsControllerFindTodosInfiniteQueryKey = (options?: Options<LmsControllerFindTodosData>): QueryKey<Options<LmsControllerFindTodosData>> => createQueryKey('lmsControllerFindTodos', options, true);

/**
 * Retrieve multiple todos
 * Requires `STUDENT` role.
 */
export const lmsControllerFindTodosInfiniteOptions = (options?: Options<LmsControllerFindTodosData>) => {
    return infiniteQueryOptions<LmsControllerFindTodosResponse, LmsControllerFindTodosError, InfiniteData<LmsControllerFindTodosResponse>, QueryKey<Options<LmsControllerFindTodosData>>, number | Pick<QueryKey<Options<LmsControllerFindTodosData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<LmsControllerFindTodosData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await lmsControllerFindTodos({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerFindTodosInfiniteQueryKey(options)
    });
};

export const lmsControllerFindModuleTreeQueryKey = (options: Options<LmsControllerFindModuleTreeData>) => createQueryKey('lmsControllerFindModuleTree', options);

/**
 * Get module tree structure
 * Retrieves the complete hierarchical structure of a module including all sections and content items
 */
export const lmsControllerFindModuleTreeOptions = (options: Options<LmsControllerFindModuleTreeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsControllerFindModuleTree({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerFindModuleTreeQueryKey(options)
    });
};

export const lmsControllerGetModuleProgressOverviewQueryKey = (options: Options<LmsControllerGetModuleProgressOverviewData>) => createQueryKey('lmsControllerGetModuleProgressOverview', options);

export const lmsControllerGetModuleProgressOverviewOptions = (options: Options<LmsControllerGetModuleProgressOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsControllerGetModuleProgressOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerGetModuleProgressOverviewQueryKey(options)
    });
};

export const lmsControllerGetModuleProgressDetailQueryKey = (options: Options<LmsControllerGetModuleProgressDetailData>) => createQueryKey('lmsControllerGetModuleProgressDetail', options);

export const lmsControllerGetModuleProgressDetailOptions = (options: Options<LmsControllerGetModuleProgressDetailData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsControllerGetModuleProgressDetail({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerGetModuleProgressDetailQueryKey(options)
    });
};

export const lmsControllerGetDashboardProgressQueryKey = (options?: Options<LmsControllerGetDashboardProgressData>) => createQueryKey('lmsControllerGetDashboardProgress', options);

export const lmsControllerGetDashboardProgressOptions = (options?: Options<LmsControllerGetDashboardProgressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsControllerGetDashboardProgress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsControllerGetDashboardProgressQueryKey(options)
    });
};

export const groupControllerFindAllQueryKey = (options: Options<GroupControllerFindAllData>) => createQueryKey('groupControllerFindAll', options);

/**
 * Retrieves groups of the given module id
 * Requires `ADMIN` or `MENTOR` role
 */
export const groupControllerFindAllOptions = (options: Options<GroupControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await groupControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: groupControllerFindAllQueryKey(options)
    });
};

export const groupControllerCreateQueryKey = (options: Options<GroupControllerCreateData>) => createQueryKey('groupControllerCreate', options);

/**
 * Creates a new group
 * Requires `ADMIN` or `MENTOR` role
 */
export const groupControllerCreateOptions = (options: Options<GroupControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await groupControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: groupControllerCreateQueryKey(options)
    });
};

/**
 * Creates a new group
 * Requires `ADMIN` or `MENTOR` role
 */
export const groupControllerCreateMutation = (options?: Partial<Options<GroupControllerCreateData>>): UseMutationOptions<GroupControllerCreateResponse, GroupControllerCreateError, Options<GroupControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<GroupControllerCreateResponse, GroupControllerCreateError, Options<GroupControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await groupControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Deletes a group
 * Requires `ADMIN` or `MENTOR` role
 */
export const groupControllerRemoveMutation = (options?: Partial<Options<GroupControllerRemoveData>>): UseMutationOptions<unknown, GroupControllerRemoveError, Options<GroupControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, GroupControllerRemoveError, Options<GroupControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await groupControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Updates a group
 * Requires `ADMIN` or `MENTOR` role
 */
export const groupControllerUpdateMutation = (options?: Partial<Options<GroupControllerUpdateData>>): UseMutationOptions<GroupControllerUpdateResponse, GroupControllerUpdateError, Options<GroupControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<GroupControllerUpdateResponse, GroupControllerUpdateError, Options<GroupControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await groupControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const notificationsControllerSubscribeQueryKey = (options?: Options<NotificationsControllerSubscribeData>) => createQueryKey('notificationsControllerSubscribe', options);

/**
 * Subscribe to server-sent notifications
 * This endpoint provides a real-time stream of notifications for the authenticated user via Server-Sent Events (SSE).
 */
export const notificationsControllerSubscribeOptions = (options?: Options<NotificationsControllerSubscribeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await notificationsControllerSubscribe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: notificationsControllerSubscribeQueryKey(options)
    });
};

export const notificationsControllerGetCountQueryKey = (options?: Options<NotificationsControllerGetCountData>) => createQueryKey('notificationsControllerGetCount', options);

/**
 * Get notification counts
 * This operation returns the total, read, and unread notification counts for the authenticated user.
 */
export const notificationsControllerGetCountOptions = (options?: Options<NotificationsControllerGetCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await notificationsControllerGetCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: notificationsControllerGetCountQueryKey(options)
    });
};

export const notificationsControllerFindAllQueryKey = (options?: Options<NotificationsControllerFindAllData>) => createQueryKey('notificationsControllerFindAll', options);

/**
 * Fetch notifications
 * This operation retrieves a paginated list of notifications for the authenticated user, with optional filtering.
 */
export const notificationsControllerFindAllOptions = (options?: Options<NotificationsControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await notificationsControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: notificationsControllerFindAllQueryKey(options)
    });
};

export const notificationsControllerFindAllInfiniteQueryKey = (options?: Options<NotificationsControllerFindAllData>): QueryKey<Options<NotificationsControllerFindAllData>> => createQueryKey('notificationsControllerFindAll', options, true);

/**
 * Fetch notifications
 * This operation retrieves a paginated list of notifications for the authenticated user, with optional filtering.
 */
export const notificationsControllerFindAllInfiniteOptions = (options?: Options<NotificationsControllerFindAllData>) => {
    return infiniteQueryOptions<NotificationsControllerFindAllResponse, DefaultError, InfiniteData<NotificationsControllerFindAllResponse>, QueryKey<Options<NotificationsControllerFindAllData>>, number | Pick<QueryKey<Options<NotificationsControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<NotificationsControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await notificationsControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: notificationsControllerFindAllInfiniteQueryKey(options)
    });
};

export const notificationsControllerFindOneQueryKey = (options: Options<NotificationsControllerFindOneData>) => createQueryKey('notificationsControllerFindOne', options);

/**
 * Fetch a single notification
 * This operation retrieves a specific notification by its ID, ensuring it is accessible to the authenticated user.
 */
export const notificationsControllerFindOneOptions = (options: Options<NotificationsControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await notificationsControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: notificationsControllerFindOneQueryKey(options)
    });
};

export const notificationsControllerMarkAsReadQueryKey = (options: Options<NotificationsControllerMarkAsReadData>) => createQueryKey('notificationsControllerMarkAsRead', options);

/**
 * Mark notifications as read
 * This operation marks a list of specified notifications as read for the authenticated user.
 */
export const notificationsControllerMarkAsReadOptions = (options: Options<NotificationsControllerMarkAsReadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await notificationsControllerMarkAsRead({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: notificationsControllerMarkAsReadQueryKey(options)
    });
};

/**
 * Mark notifications as read
 * This operation marks a list of specified notifications as read for the authenticated user.
 */
export const notificationsControllerMarkAsReadMutation = (options?: Partial<Options<NotificationsControllerMarkAsReadData>>): UseMutationOptions<unknown, DefaultError, Options<NotificationsControllerMarkAsReadData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<NotificationsControllerMarkAsReadData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await notificationsControllerMarkAsRead({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const notificationsControllerMarkAllAsReadQueryKey = (options?: Options<NotificationsControllerMarkAllAsReadData>) => createQueryKey('notificationsControllerMarkAllAsRead', options);

/**
 * Mark all notifications as read
 * This operation marks all notifications as read for the authenticated user.
 */
export const notificationsControllerMarkAllAsReadOptions = (options?: Options<NotificationsControllerMarkAllAsReadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await notificationsControllerMarkAllAsRead({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: notificationsControllerMarkAllAsReadQueryKey(options)
    });
};

/**
 * Mark all notifications as read
 * This operation marks all notifications as read for the authenticated user.
 */
export const notificationsControllerMarkAllAsReadMutation = (options?: Partial<Options<NotificationsControllerMarkAllAsReadData>>): UseMutationOptions<unknown, DefaultError, Options<NotificationsControllerMarkAllAsReadData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<NotificationsControllerMarkAllAsReadData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await notificationsControllerMarkAllAsRead({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const authControllerGetMetadataQueryKey = (options: Options<AuthControllerGetMetadataData>) => createQueryKey('authControllerGetMetadata', options);

/**
 * Get User Account Metadata
 * Retrieves the supabase auth account's metadata based on the uid given
 */
export const authControllerGetMetadataOptions = (options: Options<AuthControllerGetMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authControllerGetMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authControllerGetMetadataQueryKey(options)
    });
};

export const authControllerLoginQueryKey = (options: Options<AuthControllerLoginData>) => createQueryKey('authControllerLogin', options);

/**
 * Login Account
 * Login via email & password
 */
export const authControllerLoginOptions = (options: Options<AuthControllerLoginData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authControllerLogin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authControllerLoginQueryKey(options)
    });
};

/**
 * Login Account
 * Login via email & password
 */
export const authControllerLoginMutation = (options?: Partial<Options<AuthControllerLoginData>>): UseMutationOptions<AuthControllerLoginResponse, AuthControllerLoginError, Options<AuthControllerLoginData>> => {
    const mutationOptions: UseMutationOptions<AuthControllerLoginResponse, AuthControllerLoginError, Options<AuthControllerLoginData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await authControllerLogin({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const billingControllerFindAllQueryKey = (options?: Options<BillingControllerFindAllData>) => createQueryKey('billingControllerFindAll', options);

/**
 * Fetch bills
 * Fetch bills with the option to filter and sort them.
 * Contents of the returned list will depend on the user and their role.
 * Returns a paginated response.
 */
export const billingControllerFindAllOptions = (options?: Options<BillingControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await billingControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: billingControllerFindAllQueryKey(options)
    });
};

export const billingControllerFindAllInfiniteQueryKey = (options?: Options<BillingControllerFindAllData>): QueryKey<Options<BillingControllerFindAllData>> => createQueryKey('billingControllerFindAll', options, true);

/**
 * Fetch bills
 * Fetch bills with the option to filter and sort them.
 * Contents of the returned list will depend on the user and their role.
 * Returns a paginated response.
 */
export const billingControllerFindAllInfiniteOptions = (options?: Options<BillingControllerFindAllData>) => {
    return infiniteQueryOptions<BillingControllerFindAllResponse, BillingControllerFindAllError, InfiniteData<BillingControllerFindAllResponse>, QueryKey<Options<BillingControllerFindAllData>>, number | Pick<QueryKey<Options<BillingControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<BillingControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await billingControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: billingControllerFindAllInfiniteQueryKey(options)
    });
};

export const billingControllerCreateQueryKey = (options: Options<BillingControllerCreateData>) => createQueryKey('billingControllerCreate', options);

/**
 * Create a new bill
 * Creates a new bill item and can optionally attach a user
 */
export const billingControllerCreateOptions = (options: Options<BillingControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await billingControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: billingControllerCreateQueryKey(options)
    });
};

/**
 * Create a new bill
 * Creates a new bill item and can optionally attach a user
 */
export const billingControllerCreateMutation = (options?: Partial<Options<BillingControllerCreateData>>): UseMutationOptions<BillingControllerCreateResponse, BillingControllerCreateError, Options<BillingControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<BillingControllerCreateResponse, BillingControllerCreateError, Options<BillingControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await billingControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Deletes a bill (temporary or permanent)
 * This endpoint performs either a soft delete or a permanent deletion of a bill depending on the current state of the nill or the query parameter provided:
 *
 * - If `directDelete` is true, the bill is **permanently deleted** without checking if they are already softly deleted.
 * - If `directDelete` is not provided or false:
 * - If the bill is not yet softly deleted (`deletedAt` is null), a **soft delete** is performed by setting the `deletedAt` timestamp.
 * - If the bill is already softly deleted, a **permanent delete** is executed.
 */
export const billingControllerRemoveMutation = (options?: Partial<Options<BillingControllerRemoveData>>): UseMutationOptions<unknown, BillingControllerRemoveError, Options<BillingControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, BillingControllerRemoveError, Options<BillingControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await billingControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const billingControllerFindOneQueryKey = (options: Options<BillingControllerFindOneData>) => createQueryKey('billingControllerFindOne', options);

/**
 * Fetch a single bill
 * If the user is not an admin, they are only limited to querying their own bills.
 */
export const billingControllerFindOneOptions = (options: Options<BillingControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await billingControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: billingControllerFindOneQueryKey(options)
    });
};

/**
 * Update bill data
 * Change the bill's details
 */
export const billingControllerUpdateMutation = (options?: Partial<Options<BillingControllerUpdateData>>): UseMutationOptions<BillingControllerUpdateResponse, BillingControllerUpdateError, Options<BillingControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<BillingControllerUpdateResponse, BillingControllerUpdateError, Options<BillingControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await billingControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const installmentControllerFindAllQueryKey = (options: Options<InstallmentControllerFindAllData>) => createQueryKey('installmentControllerFindAll', options);

/**
 * Fetch installments
 * Fetch installments ordered by descending createdAt date
 * Contents of the returned list will depend on the user and their role.
 * Returns a paginated response.
 */
export const installmentControllerFindAllOptions = (options: Options<InstallmentControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await installmentControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: installmentControllerFindAllQueryKey(options)
    });
};

export const installmentControllerFindOneQueryKey = (options: Options<InstallmentControllerFindOneData>) => createQueryKey('installmentControllerFindOne', options);

/**
 * Fetch a single installment
 * If the user is not an admin, they are only limited to querying their own installments.
 */
export const installmentControllerFindOneOptions = (options: Options<InstallmentControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await installmentControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: installmentControllerFindOneQueryKey(options)
    });
};

export const paymentsControllerPayQueryKey = (options: Options<PaymentsControllerPayData>) => createQueryKey('paymentsControllerPay', options);

/**
 * Initiate paymongo payment intent
 * Handles the payment intent and payment gateway redirect of paymongo
 */
export const paymentsControllerPayOptions = (options: Options<PaymentsControllerPayData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await paymentsControllerPay({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: paymentsControllerPayQueryKey(options)
    });
};

/**
 * Initiate paymongo payment intent
 * Handles the payment intent and payment gateway redirect of paymongo
 */
export const paymentsControllerPayMutation = (options?: Partial<Options<PaymentsControllerPayData>>): UseMutationOptions<PaymentsControllerPayResponse, PaymentsControllerPayError, Options<PaymentsControllerPayData>> => {
    const mutationOptions: UseMutationOptions<PaymentsControllerPayResponse, PaymentsControllerPayError, Options<PaymentsControllerPayData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await paymentsControllerPay({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const paymentsControllerFindAllQueryKey = (options: Options<PaymentsControllerFindAllData>) => createQueryKey('paymentsControllerFindAll', options);

/**
 * Fetch payments
 * Fetch payments ordered by descending payment date
 * Contents of the returned list will depend on the user and their role.
 * Returns a paginated response.
 */
export const paymentsControllerFindAllOptions = (options: Options<PaymentsControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await paymentsControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: paymentsControllerFindAllQueryKey(options)
    });
};

export const paymentsControllerCreateQueryKey = (options: Options<PaymentsControllerCreateData>) => createQueryKey('paymentsControllerCreate', options);

/**
 * Create a new payment
 * Creates a new payment item
 */
export const paymentsControllerCreateOptions = (options: Options<PaymentsControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await paymentsControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: paymentsControllerCreateQueryKey(options)
    });
};

/**
 * Create a new payment
 * Creates a new payment item
 */
export const paymentsControllerCreateMutation = (options?: Partial<Options<PaymentsControllerCreateData>>): UseMutationOptions<PaymentsControllerCreateResponse, PaymentsControllerCreateError, Options<PaymentsControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<PaymentsControllerCreateResponse, PaymentsControllerCreateError, Options<PaymentsControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await paymentsControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Deletes a payment (temporary or permanent)
 * This endpoint performs either a soft delete or a permanent deletion of a payment depending on the current state of the nill or the query parameter provided:
 *
 * - If `directDelete` is true, the payment is **permanently deleted** without checking if they are already softly deleted.
 * - If `directDelete` is not provided or false:
 * - If the payment is not yet softly deleted (`deletedAt` is null), a **soft delete** is performed by setting the `deletedAt` timestamp.
 * - If the payment is already softly deleted, a **permanent delete** is executed.
 */
export const paymentsControllerRemoveMutation = (options?: Partial<Options<PaymentsControllerRemoveData>>): UseMutationOptions<unknown, PaymentsControllerRemoveError, Options<PaymentsControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, PaymentsControllerRemoveError, Options<PaymentsControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await paymentsControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const paymentsControllerFindOneQueryKey = (options: Options<PaymentsControllerFindOneData>) => createQueryKey('paymentsControllerFindOne', options);

/**
 * Fetch a single payment
 * If the user is not an admin, they are only limited to querying their own payments.
 */
export const paymentsControllerFindOneOptions = (options: Options<PaymentsControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await paymentsControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: paymentsControllerFindOneQueryKey(options)
    });
};

/**
 * Update payment data
 * Change the payment's details
 */
export const paymentsControllerUpdateMutation = (options?: Partial<Options<PaymentsControllerUpdateData>>): UseMutationOptions<PaymentsControllerUpdateResponse, PaymentsControllerUpdateError, Options<PaymentsControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<PaymentsControllerUpdateResponse, PaymentsControllerUpdateError, Options<PaymentsControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await paymentsControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const programControllerFindAllQueryKey = (options?: Options<ProgramControllerFindAllData>) => createQueryKey('programControllerFindAll', options);

/**
 * Retrieve all programs
 * Retrieves a paginated list of programs based on the provided filters.
 * Requires `ADMIN` role.
 */
export const programControllerFindAllOptions = (options?: Options<ProgramControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: programControllerFindAllQueryKey(options)
    });
};

export const programControllerFindAllInfiniteQueryKey = (options?: Options<ProgramControllerFindAllData>): QueryKey<Options<ProgramControllerFindAllData>> => createQueryKey('programControllerFindAll', options, true);

/**
 * Retrieve all programs
 * Retrieves a paginated list of programs based on the provided filters.
 * Requires `ADMIN` role.
 */
export const programControllerFindAllInfiniteOptions = (options?: Options<ProgramControllerFindAllData>) => {
    return infiniteQueryOptions<ProgramControllerFindAllResponse, ProgramControllerFindAllError, InfiniteData<ProgramControllerFindAllResponse>, QueryKey<Options<ProgramControllerFindAllData>>, number | Pick<QueryKey<Options<ProgramControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ProgramControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await programControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: programControllerFindAllInfiniteQueryKey(options)
    });
};

export const programControllerCreateQueryKey = (options: Options<ProgramControllerCreateData>) => createQueryKey('programControllerCreate', options);

/**
 * Create a new program
 * This operation creates a new academic program.
 * Requires `ADMIN` role.
 */
export const programControllerCreateOptions = (options: Options<ProgramControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: programControllerCreateQueryKey(options)
    });
};

/**
 * Create a new program
 * This operation creates a new academic program.
 * Requires `ADMIN` role.
 */
export const programControllerCreateMutation = (options?: Partial<Options<ProgramControllerCreateData>>): UseMutationOptions<ProgramControllerCreateResponse, ProgramControllerCreateError, Options<ProgramControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<ProgramControllerCreateResponse, ProgramControllerCreateError, Options<ProgramControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await programControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const programControllerFindAllMajorsQueryKey = (options: Options<ProgramControllerFindAllMajorsData>) => createQueryKey('programControllerFindAllMajors', options);

/**
 * Retrieve all majors of a program
 * Retrieves a paginated list of majors based on the program id and provided filters.
 * Requires `ADMIN` role.
 */
export const programControllerFindAllMajorsOptions = (options: Options<ProgramControllerFindAllMajorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programControllerFindAllMajors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: programControllerFindAllMajorsQueryKey(options)
    });
};

export const programControllerFindAllMajorsInfiniteQueryKey = (options: Options<ProgramControllerFindAllMajorsData>): QueryKey<Options<ProgramControllerFindAllMajorsData>> => createQueryKey('programControllerFindAllMajors', options, true);

/**
 * Retrieve all majors of a program
 * Retrieves a paginated list of majors based on the program id and provided filters.
 * Requires `ADMIN` role.
 */
export const programControllerFindAllMajorsInfiniteOptions = (options: Options<ProgramControllerFindAllMajorsData>) => {
    return infiniteQueryOptions<ProgramControllerFindAllMajorsResponse, ProgramControllerFindAllMajorsError, InfiniteData<ProgramControllerFindAllMajorsResponse>, QueryKey<Options<ProgramControllerFindAllMajorsData>>, number | Pick<QueryKey<Options<ProgramControllerFindAllMajorsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ProgramControllerFindAllMajorsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await programControllerFindAllMajors({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: programControllerFindAllMajorsInfiniteQueryKey(options)
    });
};

/**
 * Delete a program
 * This operation permanently deletes a program from the system.
 * Requires `ADMIN` role.
 */
export const programControllerRemoveMutation = (options?: Partial<Options<ProgramControllerRemoveData>>): UseMutationOptions<ProgramControllerRemoveResponse, ProgramControllerRemoveError, Options<ProgramControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<ProgramControllerRemoveResponse, ProgramControllerRemoveError, Options<ProgramControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await programControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const programControllerFindOneQueryKey = (options: Options<ProgramControllerFindOneData>) => createQueryKey('programControllerFindOne', options);

/**
 * Retrieve a specific program by ID
 * Requires `ADMIN` role.
 */
export const programControllerFindOneOptions = (options: Options<ProgramControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: programControllerFindOneQueryKey(options)
    });
};

/**
 * Update a program
 * This operation updates the details of an existing program.
 * Requires `ADMIN` role.
 */
export const programControllerUpdateMutation = (options?: Partial<Options<ProgramControllerUpdateData>>): UseMutationOptions<ProgramControllerUpdateResponse, ProgramControllerUpdateError, Options<ProgramControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<ProgramControllerUpdateResponse, ProgramControllerUpdateError, Options<ProgramControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await programControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const chatbotControllerPromptQueryKey = (options: Options<ChatbotControllerPromptData>) => createQueryKey('chatbotControllerPrompt', options);

export const chatbotControllerPromptOptions = (options: Options<ChatbotControllerPromptData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await chatbotControllerPrompt({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: chatbotControllerPromptQueryKey(options)
    });
};

export const chatbotControllerPromptMutation = (options?: Partial<Options<ChatbotControllerPromptData>>): UseMutationOptions<ChatbotControllerPromptResponse, ChatbotControllerPromptError, Options<ChatbotControllerPromptData>> => {
    const mutationOptions: UseMutationOptions<ChatbotControllerPromptResponse, ChatbotControllerPromptError, Options<ChatbotControllerPromptData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await chatbotControllerPrompt({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const appointmentsControllerFindAllQueryKey = (options?: Options<AppointmentsControllerFindAllData>) => createQueryKey('appointmentsControllerFindAll', options);

/**
 * Fetch courses (Temporary)
 * This operation retrieves a paginated list of courses.
 */
export const appointmentsControllerFindAllOptions = (options?: Options<AppointmentsControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await appointmentsControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: appointmentsControllerFindAllQueryKey(options)
    });
};

export const appointmentsControllerFindAllInfiniteQueryKey = (options?: Options<AppointmentsControllerFindAllData>): QueryKey<Options<AppointmentsControllerFindAllData>> => createQueryKey('appointmentsControllerFindAll', options, true);

/**
 * Fetch courses (Temporary)
 * This operation retrieves a paginated list of courses.
 */
export const appointmentsControllerFindAllInfiniteOptions = (options?: Options<AppointmentsControllerFindAllData>) => {
    return infiniteQueryOptions<AppointmentsControllerFindAllResponse, AppointmentsControllerFindAllError, InfiniteData<AppointmentsControllerFindAllResponse>, QueryKey<Options<AppointmentsControllerFindAllData>>, number | Pick<QueryKey<Options<AppointmentsControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<AppointmentsControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await appointmentsControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: appointmentsControllerFindAllInfiniteQueryKey(options)
    });
};

export const appointmentsControllerCreateQueryKey = (options: Options<AppointmentsControllerCreateData>) => createQueryKey('appointmentsControllerCreate', options);

/**
 * Create a new appointment
 * This operation allows a student to create a new appointment with a mentor.
 */
export const appointmentsControllerCreateOptions = (options: Options<AppointmentsControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await appointmentsControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: appointmentsControllerCreateQueryKey(options)
    });
};

/**
 * Create a new appointment
 * This operation allows a student to create a new appointment with a mentor.
 */
export const appointmentsControllerCreateMutation = (options?: Partial<Options<AppointmentsControllerCreateData>>): UseMutationOptions<AppointmentsControllerCreateResponse, AppointmentsControllerCreateError, Options<AppointmentsControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<AppointmentsControllerCreateResponse, AppointmentsControllerCreateError, Options<AppointmentsControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await appointmentsControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const appointmentsControllerFindMentorQueryKey = (options?: Options<AppointmentsControllerFindMentorData>) => createQueryKey('appointmentsControllerFindMentor', options);

/**
 * Fetch mentors (Temporary)
 * This operation retrieves a paginated list of mentors.
 */
export const appointmentsControllerFindMentorOptions = (options?: Options<AppointmentsControllerFindMentorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await appointmentsControllerFindMentor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: appointmentsControllerFindMentorQueryKey(options)
    });
};

export const appointmentsControllerFindMentorInfiniteQueryKey = (options?: Options<AppointmentsControllerFindMentorData>): QueryKey<Options<AppointmentsControllerFindMentorData>> => createQueryKey('appointmentsControllerFindMentor', options, true);

/**
 * Fetch mentors (Temporary)
 * This operation retrieves a paginated list of mentors.
 */
export const appointmentsControllerFindMentorInfiniteOptions = (options?: Options<AppointmentsControllerFindMentorData>) => {
    return infiniteQueryOptions<AppointmentsControllerFindMentorResponse, DefaultError, InfiniteData<AppointmentsControllerFindMentorResponse>, QueryKey<Options<AppointmentsControllerFindMentorData>>, number | Pick<QueryKey<Options<AppointmentsControllerFindMentorData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<AppointmentsControllerFindMentorData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await appointmentsControllerFindMentor({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: appointmentsControllerFindMentorInfiniteQueryKey(options)
    });
};

export const appointmentsControllerFindCoursesQueryKey = (options?: Options<AppointmentsControllerFindCoursesData>) => createQueryKey('appointmentsControllerFindCourses', options);

export const appointmentsControllerFindCoursesOptions = (options?: Options<AppointmentsControllerFindCoursesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await appointmentsControllerFindCourses({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: appointmentsControllerFindCoursesQueryKey(options)
    });
};

export const appointmentsControllerFindBookedRangeQueryKey = (options: Options<AppointmentsControllerFindBookedRangeData>) => createQueryKey('appointmentsControllerFindBookedRange', options);

export const appointmentsControllerFindBookedRangeOptions = (options: Options<AppointmentsControllerFindBookedRangeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await appointmentsControllerFindBookedRange({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: appointmentsControllerFindBookedRangeQueryKey(options)
    });
};

export const appointmentsControllerFindAllBookedQueryKey = (options: Options<AppointmentsControllerFindAllBookedData>) => createQueryKey('appointmentsControllerFindAllBooked', options);

/**
 * Fetch all booked appointments for a mentor
 * This operation retrieves a list of a mentor's booked appointments within a specified date range.
 */
export const appointmentsControllerFindAllBookedOptions = (options: Options<AppointmentsControllerFindAllBookedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await appointmentsControllerFindAllBooked({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: appointmentsControllerFindAllBookedQueryKey(options)
    });
};

/**
 * Delete an appointment (temporary or permanent)
 * This endpoint soft-deletes or permanently removes an appointment based on the `directDelete` query parameter.
 */
export const appointmentsControllerRemoveMutation = (options?: Partial<Options<AppointmentsControllerRemoveData>>): UseMutationOptions<unknown, AppointmentsControllerRemoveError, Options<AppointmentsControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, AppointmentsControllerRemoveError, Options<AppointmentsControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await appointmentsControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const appointmentsControllerFindOneQueryKey = (options: Options<AppointmentsControllerFindOneData>) => createQueryKey('appointmentsControllerFindOne', options);

/**
 * Fetch a single appointment
 * This operation retrieves a single appointment by its ID, restricted to appointments associated with the authenticated user.
 */
export const appointmentsControllerFindOneOptions = (options: Options<AppointmentsControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await appointmentsControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: appointmentsControllerFindOneQueryKey(options)
    });
};

/**
 * Update appointment details
 * This operation allows a mentor to update the details of a specific appointment.
 */
export const appointmentsControllerUpdateDetailsMutation = (options?: Partial<Options<AppointmentsControllerUpdateDetailsData>>): UseMutationOptions<AppointmentsControllerUpdateDetailsResponse, AppointmentsControllerUpdateDetailsError, Options<AppointmentsControllerUpdateDetailsData>> => {
    const mutationOptions: UseMutationOptions<AppointmentsControllerUpdateDetailsResponse, AppointmentsControllerUpdateDetailsError, Options<AppointmentsControllerUpdateDetailsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await appointmentsControllerUpdateDetails({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update appointment status
 * This operation allows a student or mentor to update the status of an appointment, with role-based restrictions on which status changes are allowed.
 */
export const appointmentsControllerUpdateStatusMutation = (options?: Partial<Options<AppointmentsControllerUpdateStatusData>>): UseMutationOptions<AppointmentsControllerUpdateStatusResponse, AppointmentsControllerUpdateStatusError, Options<AppointmentsControllerUpdateStatusData>> => {
    const mutationOptions: UseMutationOptions<AppointmentsControllerUpdateStatusResponse, AppointmentsControllerUpdateStatusError, Options<AppointmentsControllerUpdateStatusData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await appointmentsControllerUpdateStatus({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enrollmentControllerFindAllEnrollmentsQueryKey = (options?: Options<EnrollmentControllerFindAllEnrollmentsData>) => createQueryKey('enrollmentControllerFindAllEnrollments', options);

/**
 * Retrieves all enrollment periods
 * Fetches a paginated list of enrollment periods.
 * Requires `ADMIN` role.
 */
export const enrollmentControllerFindAllEnrollmentsOptions = (options?: Options<EnrollmentControllerFindAllEnrollmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerFindAllEnrollments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerFindAllEnrollmentsQueryKey(options)
    });
};

export const enrollmentControllerFindAllEnrollmentsInfiniteQueryKey = (options?: Options<EnrollmentControllerFindAllEnrollmentsData>): QueryKey<Options<EnrollmentControllerFindAllEnrollmentsData>> => createQueryKey('enrollmentControllerFindAllEnrollments', options, true);

/**
 * Retrieves all enrollment periods
 * Fetches a paginated list of enrollment periods.
 * Requires `ADMIN` role.
 */
export const enrollmentControllerFindAllEnrollmentsInfiniteOptions = (options?: Options<EnrollmentControllerFindAllEnrollmentsData>) => {
    return infiniteQueryOptions<EnrollmentControllerFindAllEnrollmentsResponse, EnrollmentControllerFindAllEnrollmentsError, InfiniteData<EnrollmentControllerFindAllEnrollmentsResponse>, QueryKey<Options<EnrollmentControllerFindAllEnrollmentsData>>, number | Pick<QueryKey<Options<EnrollmentControllerFindAllEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<EnrollmentControllerFindAllEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await enrollmentControllerFindAllEnrollments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerFindAllEnrollmentsInfiniteQueryKey(options)
    });
};

export const enrollmentControllerCreateEnrollmentQueryKey = (options: Options<EnrollmentControllerCreateEnrollmentData>) => createQueryKey('enrollmentControllerCreateEnrollment', options);

/**
 * Creates a new enrollment period
 * This operation creates a new enrollment period for managing course registrations.
 * Requires `ADMIN` role.
 */
export const enrollmentControllerCreateEnrollmentOptions = (options: Options<EnrollmentControllerCreateEnrollmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerCreateEnrollment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerCreateEnrollmentQueryKey(options)
    });
};

/**
 * Creates a new enrollment period
 * This operation creates a new enrollment period for managing course registrations.
 * Requires `ADMIN` role.
 */
export const enrollmentControllerCreateEnrollmentMutation = (options?: Partial<Options<EnrollmentControllerCreateEnrollmentData>>): UseMutationOptions<EnrollmentControllerCreateEnrollmentResponse, EnrollmentControllerCreateEnrollmentError, Options<EnrollmentControllerCreateEnrollmentData>> => {
    const mutationOptions: UseMutationOptions<EnrollmentControllerCreateEnrollmentResponse, EnrollmentControllerCreateEnrollmentError, Options<EnrollmentControllerCreateEnrollmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enrollmentControllerCreateEnrollment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enrollmentControllerFindActiveEnrollmentQueryKey = (options?: Options<EnrollmentControllerFindActiveEnrollmentData>) => createQueryKey('enrollmentControllerFindActiveEnrollment', options);

/**
 * Retrieves the currently active enrollment period
 * Requires `ADMIN` or `STUDENT` roles.
 */
export const enrollmentControllerFindActiveEnrollmentOptions = (options?: Options<EnrollmentControllerFindActiveEnrollmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerFindActiveEnrollment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerFindActiveEnrollmentQueryKey(options)
    });
};

/**
 * Removes (soft or hard deletes) an enrollment period
 * Requires `ADMIN` role.
 */
export const enrollmentControllerRemoveEnrollmentMutation = (options?: Partial<Options<EnrollmentControllerRemoveEnrollmentData>>): UseMutationOptions<EnrollmentControllerRemoveEnrollmentResponse, EnrollmentControllerRemoveEnrollmentError, Options<EnrollmentControllerRemoveEnrollmentData>> => {
    const mutationOptions: UseMutationOptions<EnrollmentControllerRemoveEnrollmentResponse, EnrollmentControllerRemoveEnrollmentError, Options<EnrollmentControllerRemoveEnrollmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enrollmentControllerRemoveEnrollment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enrollmentControllerFindOneEnrollmentQueryKey = (options: Options<EnrollmentControllerFindOneEnrollmentData>) => createQueryKey('enrollmentControllerFindOneEnrollment', options);

/**
 * Retrieves a specific enrollment period by ID
 * Requires `ADMIN` role.
 */
export const enrollmentControllerFindOneEnrollmentOptions = (options: Options<EnrollmentControllerFindOneEnrollmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerFindOneEnrollment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerFindOneEnrollmentQueryKey(options)
    });
};

/**
 * Updates an enrollment period
 * Requires `ADMIN` role.
 */
export const enrollmentControllerUpdateEnrollmentMutation = (options?: Partial<Options<EnrollmentControllerUpdateEnrollmentData>>): UseMutationOptions<EnrollmentControllerUpdateEnrollmentResponse, EnrollmentControllerUpdateEnrollmentError, Options<EnrollmentControllerUpdateEnrollmentData>> => {
    const mutationOptions: UseMutationOptions<EnrollmentControllerUpdateEnrollmentResponse, EnrollmentControllerUpdateEnrollmentError, Options<EnrollmentControllerUpdateEnrollmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enrollmentControllerUpdateEnrollment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Updates the status of an enrollment period
 * Requires `ADMIN` role.
 */
export const enrollmentControllerUpdateEnrollmentStatusMutation = (options?: Partial<Options<EnrollmentControllerUpdateEnrollmentStatusData>>): UseMutationOptions<EnrollmentControllerUpdateEnrollmentStatusResponse, EnrollmentControllerUpdateEnrollmentStatusError, Options<EnrollmentControllerUpdateEnrollmentStatusData>> => {
    const mutationOptions: UseMutationOptions<EnrollmentControllerUpdateEnrollmentStatusResponse, EnrollmentControllerUpdateEnrollmentStatusError, Options<EnrollmentControllerUpdateEnrollmentStatusData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enrollmentControllerUpdateEnrollmentStatus({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseOfferingControllerFindCourseOfferingsByPeriodQueryKey = (options: Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>) => createQueryKey('courseOfferingControllerFindCourseOfferingsByPeriod', options);

/**
 * Retrieves all course offerings in a specific enrollment period
 * Fetches a paginated list of course offerings for the given period.
 * Requires `ADMIN` or `STUDENT` role.
 */
export const courseOfferingControllerFindCourseOfferingsByPeriodOptions = (options: Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseOfferingControllerFindCourseOfferingsByPeriod({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseOfferingControllerFindCourseOfferingsByPeriodQueryKey(options)
    });
};

export const courseOfferingControllerFindCourseOfferingsByPeriodInfiniteQueryKey = (options: Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>): QueryKey<Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>> => createQueryKey('courseOfferingControllerFindCourseOfferingsByPeriod', options, true);

/**
 * Retrieves all course offerings in a specific enrollment period
 * Fetches a paginated list of course offerings for the given period.
 * Requires `ADMIN` or `STUDENT` role.
 */
export const courseOfferingControllerFindCourseOfferingsByPeriodInfiniteOptions = (options: Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>) => {
    return infiniteQueryOptions<CourseOfferingControllerFindCourseOfferingsByPeriodResponse, DefaultError, InfiniteData<CourseOfferingControllerFindCourseOfferingsByPeriodResponse>, QueryKey<Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>>, number | Pick<QueryKey<Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await courseOfferingControllerFindCourseOfferingsByPeriod({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseOfferingControllerFindCourseOfferingsByPeriodInfiniteQueryKey(options)
    });
};

export const courseOfferingControllerCreateCourseOfferingQueryKey = (options: Options<CourseOfferingControllerCreateCourseOfferingData>) => createQueryKey('courseOfferingControllerCreateCourseOffering', options);

/**
 * Creates a new course offering under a specific enrollment period
 * Requires `ADMIN` role.
 */
export const courseOfferingControllerCreateCourseOfferingOptions = (options: Options<CourseOfferingControllerCreateCourseOfferingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseOfferingControllerCreateCourseOffering({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseOfferingControllerCreateCourseOfferingQueryKey(options)
    });
};

/**
 * Creates a new course offering under a specific enrollment period
 * Requires `ADMIN` role.
 */
export const courseOfferingControllerCreateCourseOfferingMutation = (options?: Partial<Options<CourseOfferingControllerCreateCourseOfferingData>>): UseMutationOptions<CourseOfferingControllerCreateCourseOfferingResponse, CourseOfferingControllerCreateCourseOfferingError, Options<CourseOfferingControllerCreateCourseOfferingData>> => {
    const mutationOptions: UseMutationOptions<CourseOfferingControllerCreateCourseOfferingResponse, CourseOfferingControllerCreateCourseOfferingError, Options<CourseOfferingControllerCreateCourseOfferingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseOfferingControllerCreateCourseOffering({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseOfferingControllerCreateCourseOfferingsByCurriculumIdQueryKey = (options: Options<CourseOfferingControllerCreateCourseOfferingsByCurriculumIdData>) => createQueryKey('courseOfferingControllerCreateCourseOfferingsByCurriculumId', options);

/**
 * Creates course offerings given a curriculum
 * Requires `ADMIN` role.
 */
export const courseOfferingControllerCreateCourseOfferingsByCurriculumIdOptions = (options: Options<CourseOfferingControllerCreateCourseOfferingsByCurriculumIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseOfferingControllerCreateCourseOfferingsByCurriculumId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseOfferingControllerCreateCourseOfferingsByCurriculumIdQueryKey(options)
    });
};

/**
 * Creates course offerings given a curriculum
 * Requires `ADMIN` role.
 */
export const courseOfferingControllerCreateCourseOfferingsByCurriculumIdMutation = (options?: Partial<Options<CourseOfferingControllerCreateCourseOfferingsByCurriculumIdData>>): UseMutationOptions<CourseOfferingControllerCreateCourseOfferingsByCurriculumIdResponse, CourseOfferingControllerCreateCourseOfferingsByCurriculumIdError, Options<CourseOfferingControllerCreateCourseOfferingsByCurriculumIdData>> => {
    const mutationOptions: UseMutationOptions<CourseOfferingControllerCreateCourseOfferingsByCurriculumIdResponse, CourseOfferingControllerCreateCourseOfferingsByCurriculumIdError, Options<CourseOfferingControllerCreateCourseOfferingsByCurriculumIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseOfferingControllerCreateCourseOfferingsByCurriculumId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Removes a course offering from a specific enrollment period
 * Requires `ADMIN` role.
 */
export const courseOfferingControllerRemoveCourseOfferingMutation = (options?: Partial<Options<CourseOfferingControllerRemoveCourseOfferingData>>): UseMutationOptions<CourseOfferingControllerRemoveCourseOfferingResponse, CourseOfferingControllerRemoveCourseOfferingError, Options<CourseOfferingControllerRemoveCourseOfferingData>> => {
    const mutationOptions: UseMutationOptions<CourseOfferingControllerRemoveCourseOfferingResponse, CourseOfferingControllerRemoveCourseOfferingError, Options<CourseOfferingControllerRemoveCourseOfferingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseOfferingControllerRemoveCourseOffering({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseOfferingControllerFindOneCourseOfferingQueryKey = (options: Options<CourseOfferingControllerFindOneCourseOfferingData>) => createQueryKey('courseOfferingControllerFindOneCourseOffering', options);

/**
 * Retrieves a specific course offering by ID
 * Requires `ADMIN` role.
 */
export const courseOfferingControllerFindOneCourseOfferingOptions = (options: Options<CourseOfferingControllerFindOneCourseOfferingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseOfferingControllerFindOneCourseOffering({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseOfferingControllerFindOneCourseOfferingQueryKey(options)
    });
};

export const courseSectionControllerFindAllCourseSectionsQueryKey = (options: Options<CourseSectionControllerFindAllCourseSectionsData>) => createQueryKey('courseSectionControllerFindAllCourseSections', options);

/**
 * Retrieves all sections for a specific enrollment period
 * Fetches a paginated list of course sections.
 * Requires `ADMIN` role.
 */
export const courseSectionControllerFindAllCourseSectionsOptions = (options: Options<CourseSectionControllerFindAllCourseSectionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseSectionControllerFindAllCourseSections({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerFindAllCourseSectionsQueryKey(options)
    });
};

export const courseSectionControllerFindAllCourseSectionsInfiniteQueryKey = (options: Options<CourseSectionControllerFindAllCourseSectionsData>): QueryKey<Options<CourseSectionControllerFindAllCourseSectionsData>> => createQueryKey('courseSectionControllerFindAllCourseSections', options, true);

/**
 * Retrieves all sections for a specific enrollment period
 * Fetches a paginated list of course sections.
 * Requires `ADMIN` role.
 */
export const courseSectionControllerFindAllCourseSectionsInfiniteOptions = (options: Options<CourseSectionControllerFindAllCourseSectionsData>) => {
    return infiniteQueryOptions<CourseSectionControllerFindAllCourseSectionsResponse, CourseSectionControllerFindAllCourseSectionsError, InfiniteData<CourseSectionControllerFindAllCourseSectionsResponse>, QueryKey<Options<CourseSectionControllerFindAllCourseSectionsData>>, number | Pick<QueryKey<Options<CourseSectionControllerFindAllCourseSectionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<CourseSectionControllerFindAllCourseSectionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await courseSectionControllerFindAllCourseSections({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerFindAllCourseSectionsInfiniteQueryKey(options)
    });
};

export const courseSectionControllerFindAllCourseSectionsForOfferingQueryKey = (options: Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>) => createQueryKey('courseSectionControllerFindAllCourseSectionsForOffering', options);

/**
 * Retrieves all sections for a specific course offering
 * Fetches a paginated list of course sections.
 * Requires `ADMIN` role.
 */
export const courseSectionControllerFindAllCourseSectionsForOfferingOptions = (options: Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseSectionControllerFindAllCourseSectionsForOffering({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerFindAllCourseSectionsForOfferingQueryKey(options)
    });
};

export const courseSectionControllerFindAllCourseSectionsForOfferingInfiniteQueryKey = (options: Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>): QueryKey<Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>> => createQueryKey('courseSectionControllerFindAllCourseSectionsForOffering', options, true);

/**
 * Retrieves all sections for a specific course offering
 * Fetches a paginated list of course sections.
 * Requires `ADMIN` role.
 */
export const courseSectionControllerFindAllCourseSectionsForOfferingInfiniteOptions = (options: Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>) => {
    return infiniteQueryOptions<CourseSectionControllerFindAllCourseSectionsForOfferingResponse, CourseSectionControllerFindAllCourseSectionsForOfferingError, InfiniteData<CourseSectionControllerFindAllCourseSectionsForOfferingResponse>, QueryKey<Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>>, number | Pick<QueryKey<Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await courseSectionControllerFindAllCourseSectionsForOffering({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerFindAllCourseSectionsForOfferingInfiniteQueryKey(options)
    });
};

export const courseSectionControllerCreateCourseSectionQueryKey = (options: Options<CourseSectionControllerCreateCourseSectionData>) => createQueryKey('courseSectionControllerCreateCourseSection', options);

/**
 * Creates a new course section under a specific course offering
 * Requires `ADMIN` role.
 */
export const courseSectionControllerCreateCourseSectionOptions = (options: Options<CourseSectionControllerCreateCourseSectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseSectionControllerCreateCourseSection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerCreateCourseSectionQueryKey(options)
    });
};

/**
 * Creates a new course section under a specific course offering
 * Requires `ADMIN` role.
 */
export const courseSectionControllerCreateCourseSectionMutation = (options?: Partial<Options<CourseSectionControllerCreateCourseSectionData>>): UseMutationOptions<CourseSectionControllerCreateCourseSectionResponse, CourseSectionControllerCreateCourseSectionError, Options<CourseSectionControllerCreateCourseSectionData>> => {
    const mutationOptions: UseMutationOptions<CourseSectionControllerCreateCourseSectionResponse, CourseSectionControllerCreateCourseSectionError, Options<CourseSectionControllerCreateCourseSectionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseSectionControllerCreateCourseSection({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Removes a course section from a specific course offering
 * Requires `ADMIN` role.
 */
export const courseSectionControllerRemoveCourseSectionMutation = (options?: Partial<Options<CourseSectionControllerRemoveCourseSectionData>>): UseMutationOptions<CourseSectionControllerRemoveCourseSectionResponse, CourseSectionControllerRemoveCourseSectionError, Options<CourseSectionControllerRemoveCourseSectionData>> => {
    const mutationOptions: UseMutationOptions<CourseSectionControllerRemoveCourseSectionResponse, CourseSectionControllerRemoveCourseSectionError, Options<CourseSectionControllerRemoveCourseSectionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseSectionControllerRemoveCourseSection({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseSectionControllerFindOneCourseSectionQueryKey = (options: Options<CourseSectionControllerFindOneCourseSectionData>) => createQueryKey('courseSectionControllerFindOneCourseSection', options);

/**
 * Retrieves a specific course section under a course offering
 * Requires `ADMIN` role.
 */
export const courseSectionControllerFindOneCourseSectionOptions = (options: Options<CourseSectionControllerFindOneCourseSectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseSectionControllerFindOneCourseSection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerFindOneCourseSectionQueryKey(options)
    });
};

/**
 * Updates a course section under a specific course offering
 * Requires `ADMIN` role.
 */
export const courseSectionControllerUpdateCourseSectionMutation = (options?: Partial<Options<CourseSectionControllerUpdateCourseSectionData>>): UseMutationOptions<CourseSectionControllerUpdateCourseSectionResponse, CourseSectionControllerUpdateCourseSectionError, Options<CourseSectionControllerUpdateCourseSectionData>> => {
    const mutationOptions: UseMutationOptions<CourseSectionControllerUpdateCourseSectionResponse, CourseSectionControllerUpdateCourseSectionError, Options<CourseSectionControllerUpdateCourseSectionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseSectionControllerUpdateCourseSection({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseSectionControllerFindOneCourseSectionByIdQueryKey = (options: Options<CourseSectionControllerFindOneCourseSectionByIdData>) => createQueryKey('courseSectionControllerFindOneCourseSectionById', options);

/**
 * Retrieve full course section record by section id (includes course and enrollmentPeriod)
 * Accessible by ADMIN, STUDENT, MENTOR
 */
export const courseSectionControllerFindOneCourseSectionByIdOptions = (options: Options<CourseSectionControllerFindOneCourseSectionByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseSectionControllerFindOneCourseSectionById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerFindOneCourseSectionByIdQueryKey(options)
    });
};

export const courseEnrollmentControllerGetCourseEnrollmentsQueryKey = (options?: Options<CourseEnrollmentControllerGetCourseEnrollmentsData>) => createQueryKey('courseEnrollmentControllerGetCourseEnrollments', options);

/**
 * Retrieve all active (enlisted) course enrollments for the authenticated user.
 * - `STUDENT` will receive their own enlisted enrollments for the active enrollment period.
 * - `ADMIN` may call this endpoint (typically for inspection); use DTO body to scope to another student when supported.
 * - Each returned record includes related course offering, course section and mentor/user data.
 */
export const courseEnrollmentControllerGetCourseEnrollmentsOptions = (options?: Options<CourseEnrollmentControllerGetCourseEnrollmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseEnrollmentControllerGetCourseEnrollments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseEnrollmentControllerGetCourseEnrollmentsQueryKey(options)
    });
};

/**
 * Retrieve all active (enlisted) course enrollments for the authenticated user.
 * - `STUDENT` will receive their own enlisted enrollments for the active enrollment period.
 * - `ADMIN` may call this endpoint (typically for inspection); use DTO body to scope to another student when supported.
 * - Each returned record includes related course offering, course section and mentor/user data.
 */
export const courseEnrollmentControllerGetCourseEnrollmentsMutation = (options?: Partial<Options<CourseEnrollmentControllerGetCourseEnrollmentsData>>): UseMutationOptions<CourseEnrollmentControllerGetCourseEnrollmentsResponse, CourseEnrollmentControllerGetCourseEnrollmentsError, Options<CourseEnrollmentControllerGetCourseEnrollmentsData>> => {
    const mutationOptions: UseMutationOptions<CourseEnrollmentControllerGetCourseEnrollmentsResponse, CourseEnrollmentControllerGetCourseEnrollmentsError, Options<CourseEnrollmentControllerGetCourseEnrollmentsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseEnrollmentControllerGetCourseEnrollments({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseEnrollmentControllerFindAllQueryKey = (options?: Options<CourseEnrollmentControllerFindAllData>) => createQueryKey('courseEnrollmentControllerFindAll', options);

/**
 * Retrieve all course enrollments with optional filters.
 * - `ADMIN` can retrieve all enrollments and apply filters.
 */
export const courseEnrollmentControllerFindAllOptions = (options?: Options<CourseEnrollmentControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseEnrollmentControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseEnrollmentControllerFindAllQueryKey(options)
    });
};

export const courseEnrollmentControllerFindAllInfiniteQueryKey = (options?: Options<CourseEnrollmentControllerFindAllData>): QueryKey<Options<CourseEnrollmentControllerFindAllData>> => createQueryKey('courseEnrollmentControllerFindAll', options, true);

/**
 * Retrieve all course enrollments with optional filters.
 * - `ADMIN` can retrieve all enrollments and apply filters.
 */
export const courseEnrollmentControllerFindAllInfiniteOptions = (options?: Options<CourseEnrollmentControllerFindAllData>) => {
    return infiniteQueryOptions<CourseEnrollmentControllerFindAllResponse, CourseEnrollmentControllerFindAllError, InfiniteData<CourseEnrollmentControllerFindAllResponse>, QueryKey<Options<CourseEnrollmentControllerFindAllData>>, number | Pick<QueryKey<Options<CourseEnrollmentControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<CourseEnrollmentControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await courseEnrollmentControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseEnrollmentControllerFindAllInfiniteQueryKey(options)
    });
};

/**
 * Drop a student from a course section.
 * - `STUDENT` can only drop themselves.
 * - `ADMIN` can drop on behalf of another student (using `studentId` in body).
 */
export const courseEnrollmentControllerDropCourseEnrollmentMutation = (options?: Partial<Options<CourseEnrollmentControllerDropCourseEnrollmentData>>): UseMutationOptions<CourseEnrollmentControllerDropCourseEnrollmentResponse, CourseEnrollmentControllerDropCourseEnrollmentError, Options<CourseEnrollmentControllerDropCourseEnrollmentData>> => {
    const mutationOptions: UseMutationOptions<CourseEnrollmentControllerDropCourseEnrollmentResponse, CourseEnrollmentControllerDropCourseEnrollmentError, Options<CourseEnrollmentControllerDropCourseEnrollmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseEnrollmentControllerDropCourseEnrollment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseEnrollmentControllerCreateCourseEnrollmentQueryKey = (options: Options<CourseEnrollmentControllerCreateCourseEnrollmentData>) => createQueryKey('courseEnrollmentControllerCreateCourseEnrollment', options);

/**
 * Enroll a student in a course section.
 * - `STUDENT` can only enroll themselves.
 * - `ADMIN` can enroll on behalf of another student (using `studentId` in body).
 */
export const courseEnrollmentControllerCreateCourseEnrollmentOptions = (options: Options<CourseEnrollmentControllerCreateCourseEnrollmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseEnrollmentControllerCreateCourseEnrollment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseEnrollmentControllerCreateCourseEnrollmentQueryKey(options)
    });
};

/**
 * Enroll a student in a course section.
 * - `STUDENT` can only enroll themselves.
 * - `ADMIN` can enroll on behalf of another student (using `studentId` in body).
 */
export const courseEnrollmentControllerCreateCourseEnrollmentMutation = (options?: Partial<Options<CourseEnrollmentControllerCreateCourseEnrollmentData>>): UseMutationOptions<CourseEnrollmentControllerCreateCourseEnrollmentResponse, CourseEnrollmentControllerCreateCourseEnrollmentError, Options<CourseEnrollmentControllerCreateCourseEnrollmentData>> => {
    const mutationOptions: UseMutationOptions<CourseEnrollmentControllerCreateCourseEnrollmentResponse, CourseEnrollmentControllerCreateCourseEnrollmentError, Options<CourseEnrollmentControllerCreateCourseEnrollmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseEnrollmentControllerCreateCourseEnrollment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseEnrollmentControllerFinalizeCourseEnrollmentQueryKey = (options: Options<CourseEnrollmentControllerFinalizeCourseEnrollmentData>) => createQueryKey('courseEnrollmentControllerFinalizeCourseEnrollment', options);

/**
 * Finalize all course enrollments for a student.
 * - Sets all enrolled courses for the student to `finalized`.
 * - `STUDENT` can finalize only their own enrollments.
 * - `ADMIN` can finalize for any student by providing `studentId` in the request body.
 */
export const courseEnrollmentControllerFinalizeCourseEnrollmentOptions = (options: Options<CourseEnrollmentControllerFinalizeCourseEnrollmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseEnrollmentControllerFinalizeCourseEnrollment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseEnrollmentControllerFinalizeCourseEnrollmentQueryKey(options)
    });
};

/**
 * Finalize all course enrollments for a student.
 * - Sets all enrolled courses for the student to `finalized`.
 * - `STUDENT` can finalize only their own enrollments.
 * - `ADMIN` can finalize for any student by providing `studentId` in the request body.
 */
export const courseEnrollmentControllerFinalizeCourseEnrollmentMutation = (options?: Partial<Options<CourseEnrollmentControllerFinalizeCourseEnrollmentData>>): UseMutationOptions<CourseEnrollmentControllerFinalizeCourseEnrollmentResponse, CourseEnrollmentControllerFinalizeCourseEnrollmentError, Options<CourseEnrollmentControllerFinalizeCourseEnrollmentData>> => {
    const mutationOptions: UseMutationOptions<CourseEnrollmentControllerFinalizeCourseEnrollmentResponse, CourseEnrollmentControllerFinalizeCourseEnrollmentError, Options<CourseEnrollmentControllerFinalizeCourseEnrollmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseEnrollmentControllerFinalizeCourseEnrollment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const majorControllerFindAllQueryKey = (options?: Options<MajorControllerFindAllData>) => createQueryKey('majorControllerFindAll', options);

/**
 * Retrieve all majors
 * Retrieves a paginated list of majors based on the provided filters.
 * Requires `ADMIN` role.
 */
export const majorControllerFindAllOptions = (options?: Options<MajorControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await majorControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: majorControllerFindAllQueryKey(options)
    });
};

export const majorControllerFindAllInfiniteQueryKey = (options?: Options<MajorControllerFindAllData>): QueryKey<Options<MajorControllerFindAllData>> => createQueryKey('majorControllerFindAll', options, true);

/**
 * Retrieve all majors
 * Retrieves a paginated list of majors based on the provided filters.
 * Requires `ADMIN` role.
 */
export const majorControllerFindAllInfiniteOptions = (options?: Options<MajorControllerFindAllData>) => {
    return infiniteQueryOptions<MajorControllerFindAllResponse, MajorControllerFindAllError, InfiniteData<MajorControllerFindAllResponse>, QueryKey<Options<MajorControllerFindAllData>>, number | Pick<QueryKey<Options<MajorControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<MajorControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await majorControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: majorControllerFindAllInfiniteQueryKey(options)
    });
};

export const majorControllerCreateQueryKey = (options: Options<MajorControllerCreateData>) => createQueryKey('majorControllerCreate', options);

/**
 * Creates a major.
 * This operation creates a new academic major.
 * Requires `ADMIN` role.
 */
export const majorControllerCreateOptions = (options: Options<MajorControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await majorControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: majorControllerCreateQueryKey(options)
    });
};

/**
 * Creates a major.
 * This operation creates a new academic major.
 * Requires `ADMIN` role.
 */
export const majorControllerCreateMutation = (options?: Partial<Options<MajorControllerCreateData>>): UseMutationOptions<MajorControllerCreateResponse, MajorControllerCreateError, Options<MajorControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<MajorControllerCreateResponse, MajorControllerCreateError, Options<MajorControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await majorControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a major
 * This operation permanently deletes a major from the system.
 * Requires `ADMIN` role.
 */
export const majorControllerRemoveMutation = (options?: Partial<Options<MajorControllerRemoveData>>): UseMutationOptions<MajorControllerRemoveResponse, MajorControllerRemoveError, Options<MajorControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<MajorControllerRemoveResponse, MajorControllerRemoveError, Options<MajorControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await majorControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const majorControllerFindOneQueryKey = (options: Options<MajorControllerFindOneData>) => createQueryKey('majorControllerFindOne', options);

/**
 * Retrieve a specific major by ID
 * Requires `ADMIN` role.
 */
export const majorControllerFindOneOptions = (options: Options<MajorControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await majorControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: majorControllerFindOneQueryKey(options)
    });
};

/**
 * Update a major
 * This operation updates the details of an existing major.
 * Requires `ADMIN` role.
 */
export const majorControllerUpdateMutation = (options?: Partial<Options<MajorControllerUpdateData>>): UseMutationOptions<MajorControllerUpdateResponse, MajorControllerUpdateError, Options<MajorControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<MajorControllerUpdateResponse, MajorControllerUpdateError, Options<MajorControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await majorControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const curriculumControllerFindAllQueryKey = (options?: Options<CurriculumControllerFindAllData>) => createQueryKey('curriculumControllerFindAll', options);

/**
 * Fetch curriculums
 * Fetches all the curriculums
 * Returns a list
 */
export const curriculumControllerFindAllOptions = (options?: Options<CurriculumControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await curriculumControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: curriculumControllerFindAllQueryKey(options)
    });
};

export const curriculumControllerCreateQueryKey = (options: Options<CurriculumControllerCreateData>) => createQueryKey('curriculumControllerCreate', options);

/**
 * Create a new curriculum
 * Creates a new curriculum with attached course plan
 */
export const curriculumControllerCreateOptions = (options: Options<CurriculumControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await curriculumControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: curriculumControllerCreateQueryKey(options)
    });
};

/**
 * Create a new curriculum
 * Creates a new curriculum with attached course plan
 */
export const curriculumControllerCreateMutation = (options?: Partial<Options<CurriculumControllerCreateData>>): UseMutationOptions<CurriculumControllerCreateResponse, CurriculumControllerCreateError, Options<CurriculumControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<CurriculumControllerCreateResponse, CurriculumControllerCreateError, Options<CurriculumControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await curriculumControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Deletes a curriculum (temporary or permanent)
 * This endpoint performs either a soft delete or a permanent deletion of a curriculum depending on the current state of the nill or the query parameter provided:
 *
 * - If `directDelete` is true, the curriculum is **permanently deleted** without checking if they are already softly deleted.
 * - If `directDelete` is not provided or false:
 * - If the curriculum is not yet softly deleted (`deletedAt` is null), a **soft delete** is performed by setting the `deletedAt` timestamp.
 * - If the curriculum is already softly deleted, a **permanent delete** is executed.
 */
export const curriculumControllerRemoveMutation = (options?: Partial<Options<CurriculumControllerRemoveData>>): UseMutationOptions<CurriculumControllerRemoveResponse, CurriculumControllerRemoveError, Options<CurriculumControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<CurriculumControllerRemoveResponse, CurriculumControllerRemoveError, Options<CurriculumControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await curriculumControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const curriculumControllerFindOneQueryKey = (options: Options<CurriculumControllerFindOneData>) => createQueryKey('curriculumControllerFindOne', options);

/**
 * Fetch a single curriculum
 * Fetch the curriculum details and the courses attached to it.
 * Can find by id or find by code with a format of (programCode-majorCode)
 */
export const curriculumControllerFindOneOptions = (options: Options<CurriculumControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await curriculumControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: curriculumControllerFindOneQueryKey(options)
    });
};

/**
 * Update curriculum
 * Updates an existing curriculum and course plan
 */
export const curriculumControllerUpdateMutation = (options?: Partial<Options<CurriculumControllerUpdateData>>): UseMutationOptions<CurriculumControllerUpdateResponse, CurriculumControllerUpdateError, Options<CurriculumControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<CurriculumControllerUpdateResponse, CurriculumControllerUpdateError, Options<CurriculumControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await curriculumControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignmentControllerUpdateMutation = (options?: Partial<Options<AssignmentControllerUpdateData>>): UseMutationOptions<unknown, AssignmentControllerUpdateError, Options<AssignmentControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<unknown, AssignmentControllerUpdateError, Options<AssignmentControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignmentControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignmentControllerSubmitQueryKey = (options: Options<AssignmentControllerSubmitData>) => createQueryKey('assignmentControllerSubmit', options);

export const assignmentControllerSubmitOptions = (options: Options<AssignmentControllerSubmitData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignmentControllerSubmit({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignmentControllerSubmitQueryKey(options)
    });
};

export const assignmentControllerSubmitMutation = (options?: Partial<Options<AssignmentControllerSubmitData>>): UseMutationOptions<unknown, AssignmentControllerSubmitError, Options<AssignmentControllerSubmitData>> => {
    const mutationOptions: UseMutationOptions<unknown, AssignmentControllerSubmitError, Options<AssignmentControllerSubmitData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignmentControllerSubmit({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignmentControllerFindAllForAdminQueryKey = (options: Options<AssignmentControllerFindAllForAdminData>) => createQueryKey('assignmentControllerFindAllForAdmin', options);

export const assignmentControllerFindAllForAdminOptions = (options: Options<AssignmentControllerFindAllForAdminData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignmentControllerFindAllForAdmin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignmentControllerFindAllForAdminQueryKey(options)
    });
};

export const assignmentControllerFindAllForAdminInfiniteQueryKey = (options: Options<AssignmentControllerFindAllForAdminData>): QueryKey<Options<AssignmentControllerFindAllForAdminData>> => createQueryKey('assignmentControllerFindAllForAdmin', options, true);

export const assignmentControllerFindAllForAdminInfiniteOptions = (options: Options<AssignmentControllerFindAllForAdminData>) => {
    return infiniteQueryOptions<AssignmentControllerFindAllForAdminResponse, AssignmentControllerFindAllForAdminError, InfiniteData<AssignmentControllerFindAllForAdminResponse>, QueryKey<Options<AssignmentControllerFindAllForAdminData>>, number | Pick<QueryKey<Options<AssignmentControllerFindAllForAdminData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<AssignmentControllerFindAllForAdminData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await assignmentControllerFindAllForAdmin({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignmentControllerFindAllForAdminInfiniteQueryKey(options)
    });
};

export const assignmentControllerFindAllForMentorQueryKey = (options: Options<AssignmentControllerFindAllForMentorData>) => createQueryKey('assignmentControllerFindAllForMentor', options);

export const assignmentControllerFindAllForMentorOptions = (options: Options<AssignmentControllerFindAllForMentorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignmentControllerFindAllForMentor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignmentControllerFindAllForMentorQueryKey(options)
    });
};

export const assignmentControllerFindAllForMentorInfiniteQueryKey = (options: Options<AssignmentControllerFindAllForMentorData>): QueryKey<Options<AssignmentControllerFindAllForMentorData>> => createQueryKey('assignmentControllerFindAllForMentor', options, true);

export const assignmentControllerFindAllForMentorInfiniteOptions = (options: Options<AssignmentControllerFindAllForMentorData>) => {
    return infiniteQueryOptions<AssignmentControllerFindAllForMentorResponse, AssignmentControllerFindAllForMentorError, InfiniteData<AssignmentControllerFindAllForMentorResponse>, QueryKey<Options<AssignmentControllerFindAllForMentorData>>, number | Pick<QueryKey<Options<AssignmentControllerFindAllForMentorData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<AssignmentControllerFindAllForMentorData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await assignmentControllerFindAllForMentor({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignmentControllerFindAllForMentorInfiniteQueryKey(options)
    });
};

export const assignmentControllerFindAllForStudentQueryKey = (options: Options<AssignmentControllerFindAllForStudentData>) => createQueryKey('assignmentControllerFindAllForStudent', options);

export const assignmentControllerFindAllForStudentOptions = (options: Options<AssignmentControllerFindAllForStudentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignmentControllerFindAllForStudent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignmentControllerFindAllForStudentQueryKey(options)
    });
};

export const assignmentControllerFindAllForStudentInfiniteQueryKey = (options: Options<AssignmentControllerFindAllForStudentData>): QueryKey<Options<AssignmentControllerFindAllForStudentData>> => createQueryKey('assignmentControllerFindAllForStudent', options, true);

export const assignmentControllerFindAllForStudentInfiniteOptions = (options: Options<AssignmentControllerFindAllForStudentData>) => {
    return infiniteQueryOptions<AssignmentControllerFindAllForStudentResponse, AssignmentControllerFindAllForStudentError, InfiniteData<AssignmentControllerFindAllForStudentResponse>, QueryKey<Options<AssignmentControllerFindAllForStudentData>>, number | Pick<QueryKey<Options<AssignmentControllerFindAllForStudentData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<AssignmentControllerFindAllForStudentData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await assignmentControllerFindAllForStudent({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignmentControllerFindAllForStudentInfiniteQueryKey(options)
    });
};

export const assignmentControllerFindOneQueryKey = (options: Options<AssignmentControllerFindOneData>) => createQueryKey('assignmentControllerFindOne', options);

export const assignmentControllerFindOneOptions = (options: Options<AssignmentControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignmentControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignmentControllerFindOneQueryKey(options)
    });
};

export const assignmentControllerFindOneForStudentQueryKey = (options: Options<AssignmentControllerFindOneForStudentData>) => createQueryKey('assignmentControllerFindOneForStudent', options);

export const assignmentControllerFindOneForStudentOptions = (options: Options<AssignmentControllerFindOneForStudentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignmentControllerFindOneForStudent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignmentControllerFindOneForStudentQueryKey(options)
    });
};

export const lmsSectionControllerFindAllModuleSectionsQueryKey = (options: Options<LmsSectionControllerFindAllModuleSectionsData>) => createQueryKey('lmsSectionControllerFindAllModuleSections', options);

/**
 * Retrieves module sections of the given module id
 */
export const lmsSectionControllerFindAllModuleSectionsOptions = (options: Options<LmsSectionControllerFindAllModuleSectionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsSectionControllerFindAllModuleSections({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsSectionControllerFindAllModuleSectionsQueryKey(options)
    });
};

export const lmsSectionControllerCreateQueryKey = (options: Options<LmsSectionControllerCreateData>) => createQueryKey('lmsSectionControllerCreate', options);

/**
 * Creates a new module section
 * Requires `ADMIN` role
 */
export const lmsSectionControllerCreateOptions = (options: Options<LmsSectionControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsSectionControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsSectionControllerCreateQueryKey(options)
    });
};

/**
 * Creates a new module section
 * Requires `ADMIN` role
 */
export const lmsSectionControllerCreateMutation = (options?: Partial<Options<LmsSectionControllerCreateData>>): UseMutationOptions<LmsSectionControllerCreateResponse, LmsSectionControllerCreateError, Options<LmsSectionControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<LmsSectionControllerCreateResponse, LmsSectionControllerCreateError, Options<LmsSectionControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsSectionControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Deletes a module section
 * Requires `ADMIN` role
 */
export const lmsSectionControllerRemoveMutation = (options?: Partial<Options<LmsSectionControllerRemoveData>>): UseMutationOptions<unknown, LmsSectionControllerRemoveError, Options<LmsSectionControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, LmsSectionControllerRemoveError, Options<LmsSectionControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsSectionControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lmsSectionControllerFindOneQueryKey = (options: Options<LmsSectionControllerFindOneData>) => createQueryKey('lmsSectionControllerFindOne', options);

/**
 * Retrieves a module section by its ID
 */
export const lmsSectionControllerFindOneOptions = (options: Options<LmsSectionControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsSectionControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsSectionControllerFindOneQueryKey(options)
    });
};

/**
 * Updates a module section
 * Requires `ADMIN` role
 */
export const lmsSectionControllerUpdateMutation = (options?: Partial<Options<LmsSectionControllerUpdateData>>): UseMutationOptions<LmsSectionControllerUpdateResponse, LmsSectionControllerUpdateError, Options<LmsSectionControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<LmsSectionControllerUpdateResponse, LmsSectionControllerUpdateError, Options<LmsSectionControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsSectionControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lmsSectionControllerPublishSectionQueryKey = (options: Options<LmsSectionControllerPublishSectionData>) => createQueryKey('lmsSectionControllerPublishSection', options);

/**
 * Publishes a section
 * Publishes a section with an optional date.
 * Requires `ADMIN` role.
 */
export const lmsSectionControllerPublishSectionOptions = (options: Options<LmsSectionControllerPublishSectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsSectionControllerPublishSection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsSectionControllerPublishSectionQueryKey(options)
    });
};

/**
 * Publishes a section
 * Publishes a section with an optional date.
 * Requires `ADMIN` role.
 */
export const lmsSectionControllerPublishSectionMutation = (options?: Partial<Options<LmsSectionControllerPublishSectionData>>): UseMutationOptions<unknown, LmsSectionControllerPublishSectionError, Options<LmsSectionControllerPublishSectionData>> => {
    const mutationOptions: UseMutationOptions<unknown, LmsSectionControllerPublishSectionError, Options<LmsSectionControllerPublishSectionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsSectionControllerPublishSection({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lmsSectionControllerUnpublishSectionQueryKey = (options: Options<LmsSectionControllerUnpublishSectionData>) => createQueryKey('lmsSectionControllerUnpublishSection', options);

/**
 * Unpublishes a section
 * Unpublishes a section.
 * Requires `ADMIN` role.
 */
export const lmsSectionControllerUnpublishSectionOptions = (options: Options<LmsSectionControllerUnpublishSectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsSectionControllerUnpublishSection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsSectionControllerUnpublishSectionQueryKey(options)
    });
};

/**
 * Unpublishes a section
 * Unpublishes a section.
 * Requires `ADMIN` role.
 */
export const lmsSectionControllerUnpublishSectionMutation = (options?: Partial<Options<LmsSectionControllerUnpublishSectionData>>): UseMutationOptions<unknown, LmsSectionControllerUnpublishSectionError, Options<LmsSectionControllerUnpublishSectionData>> => {
    const mutationOptions: UseMutationOptions<unknown, LmsSectionControllerUnpublishSectionError, Options<LmsSectionControllerUnpublishSectionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsSectionControllerUnpublishSection({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lmsContentControllerFindAllQueryKey = (options?: Options<LmsContentControllerFindAllData>) => createQueryKey('lmsContentControllerFindAll', options);

/**
 * Retrieve multiple module contents based on filters
 */
export const lmsContentControllerFindAllOptions = (options?: Options<LmsContentControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsContentControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsContentControllerFindAllQueryKey(options)
    });
};

export const lmsContentControllerFindAllInfiniteQueryKey = (options?: Options<LmsContentControllerFindAllData>): QueryKey<Options<LmsContentControllerFindAllData>> => createQueryKey('lmsContentControllerFindAll', options, true);

/**
 * Retrieve multiple module contents based on filters
 */
export const lmsContentControllerFindAllInfiniteOptions = (options?: Options<LmsContentControllerFindAllData>) => {
    return infiniteQueryOptions<LmsContentControllerFindAllResponse, LmsContentControllerFindAllError, InfiniteData<LmsContentControllerFindAllResponse>, QueryKey<Options<LmsContentControllerFindAllData>>, number | Pick<QueryKey<Options<LmsContentControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<LmsContentControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await lmsContentControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsContentControllerFindAllInfiniteQueryKey(options)
    });
};

export const lmsContentControllerCreateQueryKey = (options: Options<LmsContentControllerCreateData>) => createQueryKey('lmsContentControllerCreate', options);

/**
 * Creates a module content
 * This operation creates a new module content.
 * Requires `ADMIN` role.
 */
export const lmsContentControllerCreateOptions = (options: Options<LmsContentControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsContentControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsContentControllerCreateQueryKey(options)
    });
};

/**
 * Creates a module content
 * This operation creates a new module content.
 * Requires `ADMIN` role.
 */
export const lmsContentControllerCreateMutation = (options?: Partial<Options<LmsContentControllerCreateData>>): UseMutationOptions<LmsContentControllerCreateResponse, LmsContentControllerCreateError, Options<LmsContentControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<LmsContentControllerCreateResponse, LmsContentControllerCreateError, Options<LmsContentControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsContentControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a module content
 * This operation deletes a module content from the system.
 * Requires `ADMIN` role.
 */
export const lmsContentControllerRemoveMutation = (options?: Partial<Options<LmsContentControllerRemoveData>>): UseMutationOptions<LmsContentControllerRemoveResponse, LmsContentControllerRemoveError, Options<LmsContentControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<LmsContentControllerRemoveResponse, LmsContentControllerRemoveError, Options<LmsContentControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsContentControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lmsContentControllerFindOneQueryKey = (options: Options<LmsContentControllerFindOneData>) => createQueryKey('lmsContentControllerFindOne', options);

/**
 * Retrieve a specific module content by ID
 */
export const lmsContentControllerFindOneOptions = (options: Options<LmsContentControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsContentControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsContentControllerFindOneQueryKey(options)
    });
};

/**
 * Update a module content
 * This operation updates the details of an existing module content.
 * Requires `ADMIN` role.
 */
export const lmsContentControllerUpdateMutation = (options?: Partial<Options<LmsContentControllerUpdateData>>): UseMutationOptions<LmsContentControllerUpdateResponse, LmsContentControllerUpdateError, Options<LmsContentControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<LmsContentControllerUpdateResponse, LmsContentControllerUpdateError, Options<LmsContentControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsContentControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Publish a module content
 * This operation publishes a module content.
 * Requires `ADMIN` role.
 */
export const lmsContentControllerPublishMutation = (options?: Partial<Options<LmsContentControllerPublishData>>): UseMutationOptions<LmsContentControllerPublishResponse, LmsContentControllerPublishError, Options<LmsContentControllerPublishData>> => {
    const mutationOptions: UseMutationOptions<LmsContentControllerPublishResponse, LmsContentControllerPublishError, Options<LmsContentControllerPublishData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsContentControllerPublish({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Unpublish a module content
 * This operation unpublishes a module content
 * Requires `ADMIN` role.
 */
export const lmsContentControllerUnpublishMutation = (options?: Partial<Options<LmsContentControllerUnpublishData>>): UseMutationOptions<LmsContentControllerUnpublishResponse, LmsContentControllerUnpublishError, Options<LmsContentControllerUnpublishData>> => {
    const mutationOptions: UseMutationOptions<LmsContentControllerUnpublishResponse, LmsContentControllerUnpublishError, Options<LmsContentControllerUnpublishData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsContentControllerUnpublish({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const lmsContentControllerFindAllContentProgressQueryKey = (options: Options<LmsContentControllerFindAllContentProgressData>) => createQueryKey('lmsContentControllerFindAllContentProgress', options);

/**
 * Retrieves all content progress records for a specific module and user.
 * - Mentors can fetch progress for a specific student (provide `studentId` query param).
 * - Students can fetch their own progress.
 */
export const lmsContentControllerFindAllContentProgressOptions = (options: Options<LmsContentControllerFindAllContentProgressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsContentControllerFindAllContentProgress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsContentControllerFindAllContentProgressQueryKey(options)
    });
};

export const lmsContentControllerCreateContentProgressQueryKey = (options: Options<LmsContentControllerCreateContentProgressData>) => createQueryKey('lmsContentControllerCreateContentProgress', options);

/**
 * Creates or updates a content progress
 * Requires `STUDENT` role
 */
export const lmsContentControllerCreateContentProgressOptions = (options: Options<LmsContentControllerCreateContentProgressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await lmsContentControllerCreateContentProgress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: lmsContentControllerCreateContentProgressQueryKey(options)
    });
};

/**
 * Creates or updates a content progress
 * Requires `STUDENT` role
 */
export const lmsContentControllerCreateContentProgressMutation = (options?: Partial<Options<LmsContentControllerCreateContentProgressData>>): UseMutationOptions<LmsContentControllerCreateContentProgressResponse, LmsContentControllerCreateContentProgressError, Options<LmsContentControllerCreateContentProgressData>> => {
    const mutationOptions: UseMutationOptions<LmsContentControllerCreateContentProgressResponse, LmsContentControllerCreateContentProgressError, Options<LmsContentControllerCreateContentProgressData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await lmsContentControllerCreateContentProgress({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const submissionControllerFindAssignmentSubmissionsForAssignmentQueryKey = (options: Options<SubmissionControllerFindAssignmentSubmissionsForAssignmentData>) => createQueryKey('submissionControllerFindAssignmentSubmissionsForAssignment', options);

export const submissionControllerFindAssignmentSubmissionsForAssignmentOptions = (options: Options<SubmissionControllerFindAssignmentSubmissionsForAssignmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await submissionControllerFindAssignmentSubmissionsForAssignment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: submissionControllerFindAssignmentSubmissionsForAssignmentQueryKey(options)
    });
};

export const submissionControllerSubmitAssignmentQueryKey = (options: Options<SubmissionControllerSubmitAssignmentData>) => createQueryKey('submissionControllerSubmitAssignment', options);

export const submissionControllerSubmitAssignmentOptions = (options: Options<SubmissionControllerSubmitAssignmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await submissionControllerSubmitAssignment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: submissionControllerSubmitAssignmentQueryKey(options)
    });
};

export const submissionControllerSubmitAssignmentMutation = (options?: Partial<Options<SubmissionControllerSubmitAssignmentData>>): UseMutationOptions<SubmissionControllerSubmitAssignmentResponse, SubmissionControllerSubmitAssignmentError, Options<SubmissionControllerSubmitAssignmentData>> => {
    const mutationOptions: UseMutationOptions<SubmissionControllerSubmitAssignmentResponse, SubmissionControllerSubmitAssignmentError, Options<SubmissionControllerSubmitAssignmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await submissionControllerSubmitAssignment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const submissionControllerFindOneQueryKey = (options: Options<SubmissionControllerFindOneData>) => createQueryKey('submissionControllerFindOne', options);

export const submissionControllerFindOneOptions = (options: Options<SubmissionControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await submissionControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: submissionControllerFindOneQueryKey(options)
    });
};

export const submissionControllerGradeMutation = (options?: Partial<Options<SubmissionControllerGradeData>>): UseMutationOptions<SubmissionControllerGradeResponse, SubmissionControllerGradeError, Options<SubmissionControllerGradeData>> => {
    const mutationOptions: UseMutationOptions<SubmissionControllerGradeResponse, SubmissionControllerGradeError, Options<SubmissionControllerGradeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await submissionControllerGrade({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const submissionControllerFindAssignmentSubmissionsOfStudentQueryKey = (options: Options<SubmissionControllerFindAssignmentSubmissionsOfStudentData>) => createQueryKey('submissionControllerFindAssignmentSubmissionsOfStudent', options);

export const submissionControllerFindAssignmentSubmissionsOfStudentOptions = (options: Options<SubmissionControllerFindAssignmentSubmissionsOfStudentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await submissionControllerFindAssignmentSubmissionsOfStudent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: submissionControllerFindAssignmentSubmissionsOfStudentQueryKey(options)
    });
};

export const submissionControllerFindAssignmentSubmissionsOfStudentForAssignmentQueryKey = (options: Options<SubmissionControllerFindAssignmentSubmissionsOfStudentForAssignmentData>) => createQueryKey('submissionControllerFindAssignmentSubmissionsOfStudentForAssignment', options);

export const submissionControllerFindAssignmentSubmissionsOfStudentForAssignmentOptions = (options: Options<SubmissionControllerFindAssignmentSubmissionsOfStudentForAssignmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await submissionControllerFindAssignmentSubmissionsOfStudentForAssignment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: submissionControllerFindAssignmentSubmissionsOfStudentForAssignmentQueryKey(options)
    });
};

export const gradingControllerGetStudentGradebookQueryKey = (options?: Options<GradingControllerGetStudentGradebookData>) => createQueryKey('gradingControllerGetStudentGradebook', options);

/**
 * Get student gradebook
 * Retrieves the gradebook for the authenticated student showing their grades for submitted assignments
 */
export const gradingControllerGetStudentGradebookOptions = (options?: Options<GradingControllerGetStudentGradebookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await gradingControllerGetStudentGradebook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: gradingControllerGetStudentGradebookQueryKey(options)
    });
};

export const gradingControllerGetStudentGradebookInfiniteQueryKey = (options?: Options<GradingControllerGetStudentGradebookData>): QueryKey<Options<GradingControllerGetStudentGradebookData>> => createQueryKey('gradingControllerGetStudentGradebook', options, true);

/**
 * Get student gradebook
 * Retrieves the gradebook for the authenticated student showing their grades for submitted assignments
 */
export const gradingControllerGetStudentGradebookInfiniteOptions = (options?: Options<GradingControllerGetStudentGradebookData>) => {
    return infiniteQueryOptions<GradingControllerGetStudentGradebookResponse, GradingControllerGetStudentGradebookError, InfiniteData<GradingControllerGetStudentGradebookResponse>, QueryKey<Options<GradingControllerGetStudentGradebookData>>, number | Pick<QueryKey<Options<GradingControllerGetStudentGradebookData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GradingControllerGetStudentGradebookData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await gradingControllerGetStudentGradebook({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: gradingControllerGetStudentGradebookInfiniteQueryKey(options)
    });
};

export const gradingControllerGetMentorGradebookQueryKey = (options?: Options<GradingControllerGetMentorGradebookData>) => createQueryKey('gradingControllerGetMentorGradebook', options);

/**
 * Get mentor gradebook
 * Retrieves gradebook data for all students in courses the mentor is assigned to
 */
export const gradingControllerGetMentorGradebookOptions = (options?: Options<GradingControllerGetMentorGradebookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await gradingControllerGetMentorGradebook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: gradingControllerGetMentorGradebookQueryKey(options)
    });
};

export const gradingControllerGetMentorGradebookInfiniteQueryKey = (options?: Options<GradingControllerGetMentorGradebookData>): QueryKey<Options<GradingControllerGetMentorGradebookData>> => createQueryKey('gradingControllerGetMentorGradebook', options, true);

/**
 * Get mentor gradebook
 * Retrieves gradebook data for all students in courses the mentor is assigned to
 */
export const gradingControllerGetMentorGradebookInfiniteOptions = (options?: Options<GradingControllerGetMentorGradebookData>) => {
    return infiniteQueryOptions<GradingControllerGetMentorGradebookResponse, GradingControllerGetMentorGradebookError, InfiniteData<GradingControllerGetMentorGradebookResponse>, QueryKey<Options<GradingControllerGetMentorGradebookData>>, number | Pick<QueryKey<Options<GradingControllerGetMentorGradebookData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GradingControllerGetMentorGradebookData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await gradingControllerGetMentorGradebook({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: gradingControllerGetMentorGradebookInfiniteQueryKey(options)
    });
};

export const gradingControllerGetAdminGradebookQueryKey = (options?: Options<GradingControllerGetAdminGradebookData>) => createQueryKey('gradingControllerGetAdminGradebook', options);

/**
 * Get admin gradebook
 * Retrieves gradebook data across all courses and students in the system
 */
export const gradingControllerGetAdminGradebookOptions = (options?: Options<GradingControllerGetAdminGradebookData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await gradingControllerGetAdminGradebook({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: gradingControllerGetAdminGradebookQueryKey(options)
    });
};

export const gradingControllerGetAdminGradebookInfiniteQueryKey = (options?: Options<GradingControllerGetAdminGradebookData>): QueryKey<Options<GradingControllerGetAdminGradebookData>> => createQueryKey('gradingControllerGetAdminGradebook', options, true);

/**
 * Get admin gradebook
 * Retrieves gradebook data across all courses and students in the system
 */
export const gradingControllerGetAdminGradebookInfiniteOptions = (options?: Options<GradingControllerGetAdminGradebookData>) => {
    return infiniteQueryOptions<GradingControllerGetAdminGradebookResponse, GradingControllerGetAdminGradebookError, InfiniteData<GradingControllerGetAdminGradebookResponse>, QueryKey<Options<GradingControllerGetAdminGradebookData>>, number | Pick<QueryKey<Options<GradingControllerGetAdminGradebookData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GradingControllerGetAdminGradebookData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await gradingControllerGetAdminGradebook({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: gradingControllerGetAdminGradebookInfiniteQueryKey(options)
    });
};

export const gradingControllerGradeAssignmentSubmissionQueryKey = (options: Options<GradingControllerGradeAssignmentSubmissionData>) => createQueryKey('gradingControllerGradeAssignmentSubmission', options);

/**
 * Grade assignment submission
 * Creates a grade record for a student assignment submission
 */
export const gradingControllerGradeAssignmentSubmissionOptions = (options: Options<GradingControllerGradeAssignmentSubmissionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await gradingControllerGradeAssignmentSubmission({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: gradingControllerGradeAssignmentSubmissionQueryKey(options)
    });
};

/**
 * Grade assignment submission
 * Creates a grade record for a student assignment submission
 */
export const gradingControllerGradeAssignmentSubmissionMutation = (options?: Partial<Options<GradingControllerGradeAssignmentSubmissionData>>): UseMutationOptions<GradingControllerGradeAssignmentSubmissionResponse, GradingControllerGradeAssignmentSubmissionError, Options<GradingControllerGradeAssignmentSubmissionData>> => {
    const mutationOptions: UseMutationOptions<GradingControllerGradeAssignmentSubmissionResponse, GradingControllerGradeAssignmentSubmissionError, Options<GradingControllerGradeAssignmentSubmissionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await gradingControllerGradeAssignmentSubmission({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update grade record
 * Updates an existing grade record for an assignment submission
 */
export const gradingControllerUpdateGradeRecordMutation = (options?: Partial<Options<GradingControllerUpdateGradeRecordData>>): UseMutationOptions<GradingControllerUpdateGradeRecordResponse, GradingControllerUpdateGradeRecordError, Options<GradingControllerUpdateGradeRecordData>> => {
    const mutationOptions: UseMutationOptions<GradingControllerUpdateGradeRecordResponse, GradingControllerUpdateGradeRecordError, Options<GradingControllerUpdateGradeRecordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await gradingControllerUpdateGradeRecord({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const swaggerControllerDownloadAllSpecsQueryKey = (options?: Options<SwaggerControllerDownloadAllSpecsData>) => createQueryKey('swaggerControllerDownloadAllSpecs', options);

export const swaggerControllerDownloadAllSpecsOptions = (options?: Options<SwaggerControllerDownloadAllSpecsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await swaggerControllerDownloadAllSpecs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: swaggerControllerDownloadAllSpecsQueryKey(options)
    });
};

export const pricingControllerFindAllQueryKey = (options?: Options<PricingControllerFindAllData>) => createQueryKey('pricingControllerFindAll', options);

/**
 * Fetch all pricings
 * This operation retrieves a paginated list of all pricing entries.
 */
export const pricingControllerFindAllOptions = (options?: Options<PricingControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricingControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricingControllerFindAllQueryKey(options)
    });
};

export const pricingControllerFindAllInfiniteQueryKey = (options?: Options<PricingControllerFindAllData>): QueryKey<Options<PricingControllerFindAllData>> => createQueryKey('pricingControllerFindAll', options, true);

/**
 * Fetch all pricings
 * This operation retrieves a paginated list of all pricing entries.
 */
export const pricingControllerFindAllInfiniteOptions = (options?: Options<PricingControllerFindAllData>) => {
    return infiniteQueryOptions<PricingControllerFindAllResponse, PricingControllerFindAllError, InfiniteData<PricingControllerFindAllResponse>, QueryKey<Options<PricingControllerFindAllData>>, number | Pick<QueryKey<Options<PricingControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<PricingControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await pricingControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricingControllerFindAllInfiniteQueryKey(options)
    });
};

export const pricingControllerCreateQueryKey = (options: Options<PricingControllerCreateData>) => createQueryKey('pricingControllerCreate', options);

/**
 * Create a new pricing fee
 * This operation creates a new pricing entry in the database.
 */
export const pricingControllerCreateOptions = (options: Options<PricingControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricingControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricingControllerCreateQueryKey(options)
    });
};

/**
 * Create a new pricing fee
 * This operation creates a new pricing entry in the database.
 */
export const pricingControllerCreateMutation = (options?: Partial<Options<PricingControllerCreateData>>): UseMutationOptions<PricingControllerCreateResponse, PricingControllerCreateError, Options<PricingControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<PricingControllerCreateResponse, PricingControllerCreateError, Options<PricingControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await pricingControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a pricing (temporary or permanent)
 * This endpoint performs either a **soft delete** or a **permanent deletion** of a pricing.
 * - If `directDelete` is true, the pricing is permanently deleted.
 * - If `directDelete` is not provided or false:
 * - If the pricing has not been soft-deleted yet, it will be soft-deleted by setting the `deletedAt` timestamp.
 * - If the pricing has already been soft-deleted, it will be permanently deleted.
 */
export const pricingControllerRemoveMutation = (options?: Partial<Options<PricingControllerRemoveData>>): UseMutationOptions<unknown, PricingControllerRemoveError, Options<PricingControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, PricingControllerRemoveError, Options<PricingControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await pricingControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pricingControllerFindOneQueryKey = (options: Options<PricingControllerFindOneData>) => createQueryKey('pricingControllerFindOne', options);

/**
 * Fetch a single pricing
 * This operation retrieves a single pricing entry by its id.
 */
export const pricingControllerFindOneOptions = (options: Options<PricingControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricingControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricingControllerFindOneQueryKey(options)
    });
};

/**
 * Update a pricing entry
 * This operation updates the details of a single pricing fee by its ID.
 */
export const pricingControllerUpdateMutation = (options?: Partial<Options<PricingControllerUpdateData>>): UseMutationOptions<PricingControllerUpdateResponse, PricingControllerUpdateError, Options<PricingControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<PricingControllerUpdateResponse, PricingControllerUpdateError, Options<PricingControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await pricingControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pricingGroupControllerFindAllQueryKey = (options?: Options<PricingGroupControllerFindAllData>) => createQueryKey('pricingGroupControllerFindAll', options);

/**
 * Fetch all pricing groups
 * This operation retrieves a paginated list of all pricing groups.
 */
export const pricingGroupControllerFindAllOptions = (options?: Options<PricingGroupControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricingGroupControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricingGroupControllerFindAllQueryKey(options)
    });
};

export const pricingGroupControllerFindAllInfiniteQueryKey = (options?: Options<PricingGroupControllerFindAllData>): QueryKey<Options<PricingGroupControllerFindAllData>> => createQueryKey('pricingGroupControllerFindAll', options, true);

/**
 * Fetch all pricing groups
 * This operation retrieves a paginated list of all pricing groups.
 */
export const pricingGroupControllerFindAllInfiniteOptions = (options?: Options<PricingGroupControllerFindAllData>) => {
    return infiniteQueryOptions<PricingGroupControllerFindAllResponse, PricingGroupControllerFindAllError, InfiniteData<PricingGroupControllerFindAllResponse>, QueryKey<Options<PricingGroupControllerFindAllData>>, number | Pick<QueryKey<Options<PricingGroupControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<PricingGroupControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await pricingGroupControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricingGroupControllerFindAllInfiniteQueryKey(options)
    });
};

export const pricingGroupControllerCreateQueryKey = (options: Options<PricingGroupControllerCreateData>) => createQueryKey('pricingGroupControllerCreate', options);

/**
 * Create a new pricing group
 * This operation creates a new pricing group and links it to existing pricing entries.
 */
export const pricingGroupControllerCreateOptions = (options: Options<PricingGroupControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricingGroupControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricingGroupControllerCreateQueryKey(options)
    });
};

/**
 * Create a new pricing group
 * This operation creates a new pricing group and links it to existing pricing entries.
 */
export const pricingGroupControllerCreateMutation = (options?: Partial<Options<PricingGroupControllerCreateData>>): UseMutationOptions<PricingGroupControllerCreateResponse, PricingGroupControllerCreateError, Options<PricingGroupControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<PricingGroupControllerCreateResponse, PricingGroupControllerCreateError, Options<PricingGroupControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await pricingGroupControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a pricing group (temporary or permanent)
 * This endpoint soft or permanently deletes a pricing group based on its `deletedAt` status or a query parameter.
 */
export const pricingGroupControllerRemoveMutation = (options?: Partial<Options<PricingGroupControllerRemoveData>>): UseMutationOptions<unknown, PricingGroupControllerRemoveError, Options<PricingGroupControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, PricingGroupControllerRemoveError, Options<PricingGroupControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await pricingGroupControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pricingGroupControllerFindOneQueryKey = (options: Options<PricingGroupControllerFindOneData>) => createQueryKey('pricingGroupControllerFindOne', options);

/**
 * Fetch a single pricing group
 * This operation retrieves a single pricing group by its ID, including its associated prices.
 */
export const pricingGroupControllerFindOneOptions = (options: Options<PricingGroupControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await pricingGroupControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: pricingGroupControllerFindOneQueryKey(options)
    });
};

/**
 * Update a pricing group
 * This operation updates an existing pricing group and its associated prices.
 */
export const pricingGroupControllerUpdateMutation = (options?: Partial<Options<PricingGroupControllerUpdateData>>): UseMutationOptions<PricingGroupControllerUpdateResponse, PricingGroupControllerUpdateError, Options<PricingGroupControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<PricingGroupControllerUpdateResponse, PricingGroupControllerUpdateError, Options<PricingGroupControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await pricingGroupControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const transcriptControllerFindAllQueryKey = (options?: Options<TranscriptControllerFindAllData>) => createQueryKey('transcriptControllerFindAll', options);

/**
 * Fetch transcripts
 * Fetch transcripts with the option to filter them.
 * Requires `ADMIN`, `MENTOR`, or `STUDENT` role.
 * Returns a list of transcripts.
 */
export const transcriptControllerFindAllOptions = (options?: Options<TranscriptControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await transcriptControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: transcriptControllerFindAllQueryKey(options)
    });
};

/**
 * Upsert a transcript record
 * Creates or updates a transcript record for a student in a specific course offering.
 * If a transcript for the given student and course offering already exists, it will be updated.
 * If not, a new transcript record will be created.
 * Requires `ADMIN` or `MENTOR` role.
 */
export const transcriptControllerUpsertMutation = (options?: Partial<Options<TranscriptControllerUpsertData>>): UseMutationOptions<TranscriptControllerUpsertResponse, TranscriptControllerUpsertError, Options<TranscriptControllerUpsertData>> => {
    const mutationOptions: UseMutationOptions<TranscriptControllerUpsertResponse, TranscriptControllerUpsertError, Options<TranscriptControllerUpsertData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await transcriptControllerUpsert({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a transcript record
 * Deletes a transcript record identified by its ID.
 * If `directDelete` query parameter is set to true, the record will be permanently deleted.
 * Otherwise, it may be soft-deleted based on the service implementation.
 * Requires `ADMIN` role.
 */
export const transcriptControllerRemoveMutation = (options?: Partial<Options<TranscriptControllerRemoveData>>): UseMutationOptions<unknown, TranscriptControllerRemoveError, Options<TranscriptControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, TranscriptControllerRemoveError, Options<TranscriptControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await transcriptControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const transcriptControllerFindOneTranscriptQueryKey = (options: Options<TranscriptControllerFindOneTranscriptData>) => createQueryKey('transcriptControllerFindOneTranscript', options);

/**
 * Fetch a single transcript record
 * Retrieves a specific transcript record by ID with all related information.
 * Requires `ADMIN`, `MENTOR`, or `STUDENT` role.
 */
export const transcriptControllerFindOneTranscriptOptions = (options: Options<TranscriptControllerFindOneTranscriptData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await transcriptControllerFindOneTranscript({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: transcriptControllerFindOneTranscriptQueryKey(options)
    });
};

/**
 * Update a transcript record
 * Updates the details of an existing transcript record identified by its ID.
 * Allows updating grade and grade letter values.
 * Requires `ADMIN` or `MENTOR` role.
 */
export const transcriptControllerUpdateMutation = (options?: Partial<Options<TranscriptControllerUpdateData>>): UseMutationOptions<TranscriptControllerUpdateResponse, TranscriptControllerUpdateError, Options<TranscriptControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<TranscriptControllerUpdateResponse, TranscriptControllerUpdateError, Options<TranscriptControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await transcriptControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};