// This file is auto-generated by @hey-api/openapi-ts

import { type Options, testControllerTestStudent, testControllerTestAdmin, testControllerTest, usersControllerFindAll, usersControllerCreate, usersControllerCreateStudent, usersControllerCreateStaff, usersControllerInviteUser, usersControllerGetMe, usersControllerUpdateOwnUserDetails, usersControllerUpdateUserStudentDetails, usersControllerUpdateUserStaffDetails, usersControllerRemove, usersControllerFindOne, usersControllerUpdateUserStatus, coursesControllerFindAll, coursesControllerCreate, coursesControllerRemove, coursesControllerFindOne, coursesControllerUpdate, authControllerGetMetadata, authControllerLogin, billingControllerFindAll, billingControllerCreate, billingControllerRemove, billingControllerFindOne, billingControllerUpdate, installmentControllerFindAll, installmentControllerFindOne, paymentsControllerPay, paymentsControllerFindAll, paymentsControllerCreate, paymentsControllerRemove, paymentsControllerFindOne, paymentsControllerUpdate, programControllerFindAll, programControllerCreate, programControllerFindAllMajors, programControllerRemove, programControllerFindOne, programControllerUpdate, chatbotControllerPrompt, majorControllerFindAll, majorControllerCreate, majorControllerRemove, majorControllerFindOne, majorControllerUpdate, enrollmentControllerFindAllEnrollments, enrollmentControllerCreateEnrollment, enrollmentControllerFindActiveEnrollment, enrollmentControllerRemoveEnrollment, enrollmentControllerFindOneEnrollment, enrollmentControllerUpdateEnrollment, enrollmentControllerUpdateEnrollmentStatus, courseOfferingControllerFindCourseOfferingsByPeriod, courseOfferingControllerCreateCourseOffering, courseOfferingControllerRemoveCourseOffering, courseOfferingControllerFindOneCourseOffering, courseSectionControllerFindAllCourseSections, courseSectionControllerFindAllCourseSectionsForOffering, courseSectionControllerCreateCourseSection, courseSectionControllerRemoveCourseSection, courseSectionControllerFindOneCourseSection, courseSectionControllerUpdateCourseSection, courseEnrollmentControllerGetCourseEnrollments, courseEnrollmentControllerDropCourseEnrollment, courseEnrollmentControllerCreateCourseEnrollment, courseEnrollmentControllerFinalizeCourseEnrollment, curriculumControllerFindAll, curriculumControllerCreate, curriculumControllerRemove, curriculumControllerFindOne, curriculumControllerUpdate, swaggerControllerDownloadAllSpecs } from '../sdk.gen';
import { queryOptions, infiniteQueryOptions, type InfiniteData, type DefaultError, type UseMutationOptions } from '@tanstack/react-query';
import type { TestControllerTestStudentData, TestControllerTestAdminData, TestControllerTestData, TestControllerTestResponse, UsersControllerFindAllData, UsersControllerFindAllError, UsersControllerFindAllResponse, UsersControllerCreateData, UsersControllerCreateError, UsersControllerCreateResponse, UsersControllerCreateStudentData, UsersControllerCreateStudentError, UsersControllerCreateStudentResponse, UsersControllerCreateStaffData, UsersControllerCreateStaffError, UsersControllerCreateStaffResponse, UsersControllerInviteUserData, UsersControllerInviteUserError, UsersControllerInviteUserResponse, UsersControllerGetMeData, UsersControllerUpdateOwnUserDetailsData, UsersControllerUpdateOwnUserDetailsError, UsersControllerUpdateOwnUserDetailsResponse, UsersControllerUpdateUserStudentDetailsData, UsersControllerUpdateUserStudentDetailsError, UsersControllerUpdateUserStudentDetailsResponse, UsersControllerUpdateUserStaffDetailsData, UsersControllerUpdateUserStaffDetailsError, UsersControllerUpdateUserStaffDetailsResponse, UsersControllerRemoveData, UsersControllerRemoveError, UsersControllerRemoveResponse, UsersControllerFindOneData, UsersControllerUpdateUserStatusData, UsersControllerUpdateUserStatusError, UsersControllerUpdateUserStatusResponse, CoursesControllerFindAllData, CoursesControllerFindAllError, CoursesControllerFindAllResponse, CoursesControllerCreateData, CoursesControllerCreateError, CoursesControllerCreateResponse, CoursesControllerRemoveData, CoursesControllerRemoveError, CoursesControllerRemoveResponse, CoursesControllerFindOneData, CoursesControllerUpdateData, CoursesControllerUpdateError, CoursesControllerUpdateResponse, AuthControllerGetMetadataData, AuthControllerLoginData, AuthControllerLoginError, AuthControllerLoginResponse, BillingControllerFindAllData, BillingControllerFindAllError, BillingControllerFindAllResponse, BillingControllerCreateData, BillingControllerCreateError, BillingControllerCreateResponse, BillingControllerRemoveData, BillingControllerRemoveError, BillingControllerFindOneData, BillingControllerUpdateData, BillingControllerUpdateError, BillingControllerUpdateResponse, InstallmentControllerFindAllData, InstallmentControllerFindOneData, PaymentsControllerPayData, PaymentsControllerPayError, PaymentsControllerPayResponse, PaymentsControllerFindAllData, PaymentsControllerCreateData, PaymentsControllerCreateError, PaymentsControllerCreateResponse, PaymentsControllerRemoveData, PaymentsControllerRemoveError, PaymentsControllerFindOneData, PaymentsControllerUpdateData, PaymentsControllerUpdateError, PaymentsControllerUpdateResponse, ProgramControllerFindAllData, ProgramControllerFindAllError, ProgramControllerFindAllResponse, ProgramControllerCreateData, ProgramControllerCreateError, ProgramControllerCreateResponse, ProgramControllerFindAllMajorsData, ProgramControllerFindAllMajorsError, ProgramControllerFindAllMajorsResponse, ProgramControllerRemoveData, ProgramControllerRemoveError, ProgramControllerRemoveResponse, ProgramControllerFindOneData, ProgramControllerUpdateData, ProgramControllerUpdateError, ProgramControllerUpdateResponse, ChatbotControllerPromptData, ChatbotControllerPromptError, ChatbotControllerPromptResponse, MajorControllerFindAllData, MajorControllerFindAllError, MajorControllerFindAllResponse, MajorControllerCreateData, MajorControllerCreateError, MajorControllerCreateResponse, MajorControllerRemoveData, MajorControllerRemoveError, MajorControllerRemoveResponse, MajorControllerFindOneData, MajorControllerUpdateData, MajorControllerUpdateError, MajorControllerUpdateResponse, EnrollmentControllerFindAllEnrollmentsData, EnrollmentControllerFindAllEnrollmentsError, EnrollmentControllerFindAllEnrollmentsResponse, EnrollmentControllerCreateEnrollmentData, EnrollmentControllerCreateEnrollmentError, EnrollmentControllerCreateEnrollmentResponse, EnrollmentControllerFindActiveEnrollmentData, EnrollmentControllerRemoveEnrollmentData, EnrollmentControllerRemoveEnrollmentError, EnrollmentControllerRemoveEnrollmentResponse, EnrollmentControllerFindOneEnrollmentData, EnrollmentControllerUpdateEnrollmentData, EnrollmentControllerUpdateEnrollmentError, EnrollmentControllerUpdateEnrollmentResponse, EnrollmentControllerUpdateEnrollmentStatusData, EnrollmentControllerUpdateEnrollmentStatusError, EnrollmentControllerUpdateEnrollmentStatusResponse, CourseOfferingControllerFindCourseOfferingsByPeriodData, CourseOfferingControllerFindCourseOfferingsByPeriodResponse, CourseOfferingControllerCreateCourseOfferingData, CourseOfferingControllerCreateCourseOfferingError, CourseOfferingControllerCreateCourseOfferingResponse, CourseOfferingControllerRemoveCourseOfferingData, CourseOfferingControllerRemoveCourseOfferingError, CourseOfferingControllerRemoveCourseOfferingResponse, CourseOfferingControllerFindOneCourseOfferingData, CourseSectionControllerFindAllCourseSectionsData, CourseSectionControllerFindAllCourseSectionsError, CourseSectionControllerFindAllCourseSectionsResponse, CourseSectionControllerFindAllCourseSectionsForOfferingData, CourseSectionControllerFindAllCourseSectionsForOfferingError, CourseSectionControllerFindAllCourseSectionsForOfferingResponse, CourseSectionControllerCreateCourseSectionData, CourseSectionControllerCreateCourseSectionError, CourseSectionControllerCreateCourseSectionResponse, CourseSectionControllerRemoveCourseSectionData, CourseSectionControllerRemoveCourseSectionError, CourseSectionControllerRemoveCourseSectionResponse, CourseSectionControllerFindOneCourseSectionData, CourseSectionControllerUpdateCourseSectionData, CourseSectionControllerUpdateCourseSectionError, CourseSectionControllerUpdateCourseSectionResponse, CourseEnrollmentControllerGetCourseEnrollmentsData, CourseEnrollmentControllerGetCourseEnrollmentsError, CourseEnrollmentControllerGetCourseEnrollmentsResponse, CourseEnrollmentControllerDropCourseEnrollmentData, CourseEnrollmentControllerDropCourseEnrollmentError, CourseEnrollmentControllerDropCourseEnrollmentResponse, CourseEnrollmentControllerCreateCourseEnrollmentData, CourseEnrollmentControllerCreateCourseEnrollmentError, CourseEnrollmentControllerCreateCourseEnrollmentResponse, CourseEnrollmentControllerFinalizeCourseEnrollmentData, CourseEnrollmentControllerFinalizeCourseEnrollmentError, CourseEnrollmentControllerFinalizeCourseEnrollmentResponse, CurriculumControllerFindAllData, CurriculumControllerCreateData, CurriculumControllerCreateError, CurriculumControllerCreateResponse, CurriculumControllerRemoveData, CurriculumControllerRemoveError, CurriculumControllerFindOneData, CurriculumControllerUpdateData, CurriculumControllerUpdateError, CurriculumControllerUpdateResponse, SwaggerControllerDownloadAllSpecsData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const testControllerTestStudentQueryKey = (options?: Options<TestControllerTestStudentData>) => createQueryKey('testControllerTestStudent', options);

export const testControllerTestStudentOptions = (options?: Options<TestControllerTestStudentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testControllerTestStudent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testControllerTestStudentQueryKey(options)
    });
};

export const testControllerTestAdminQueryKey = (options?: Options<TestControllerTestAdminData>) => createQueryKey('testControllerTestAdmin', options);

export const testControllerTestAdminOptions = (options?: Options<TestControllerTestAdminData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testControllerTestAdmin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testControllerTestAdminQueryKey(options)
    });
};

export const testControllerTestQueryKey = (options: Options<TestControllerTestData>) => createQueryKey('testControllerTest', options);

/**
 * Logging Test
 * Test the logging & prisma error handling functionality
 */
export const testControllerTestOptions = (options: Options<TestControllerTestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testControllerTest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testControllerTestQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const testControllerTestInfiniteQueryKey = (options: Options<TestControllerTestData>): QueryKey<Options<TestControllerTestData>> => createQueryKey('testControllerTest', options, true);

/**
 * Logging Test
 * Test the logging & prisma error handling functionality
 */
export const testControllerTestInfiniteOptions = (options: Options<TestControllerTestData>) => {
    return infiniteQueryOptions<TestControllerTestResponse, DefaultError, InfiniteData<TestControllerTestResponse>, QueryKey<Options<TestControllerTestData>>, number | Pick<QueryKey<Options<TestControllerTestData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<TestControllerTestData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await testControllerTest({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testControllerTestInfiniteQueryKey(options)
    });
};

/**
 * Logging Test
 * Test the logging & prisma error handling functionality
 */
export const testControllerTestMutation = (options?: Partial<Options<TestControllerTestData>>): UseMutationOptions<TestControllerTestResponse, DefaultError, Options<TestControllerTestData>> => {
    const mutationOptions: UseMutationOptions<TestControllerTestResponse, DefaultError, Options<TestControllerTestData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await testControllerTest({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerFindAllQueryKey = (options?: Options<UsersControllerFindAllData>) => createQueryKey('usersControllerFindAll', options);

/**
 * Get users
 * Retrieves a paginated list of users based on the provided filter parameters.
 * - **Access: ** Requires `ADMIN` role.
 * - **Filtering & Pagination: ** Uses the `FilterUserDto` to define query parameters such as search terms, sorting, and page size.
 */
export const usersControllerFindAllOptions = (options?: Options<UsersControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerFindAllQueryKey(options)
    });
};

export const usersControllerFindAllInfiniteQueryKey = (options?: Options<UsersControllerFindAllData>): QueryKey<Options<UsersControllerFindAllData>> => createQueryKey('usersControllerFindAll', options, true);

/**
 * Get users
 * Retrieves a paginated list of users based on the provided filter parameters.
 * - **Access: ** Requires `ADMIN` role.
 * - **Filtering & Pagination: ** Uses the `FilterUserDto` to define query parameters such as search terms, sorting, and page size.
 */
export const usersControllerFindAllInfiniteOptions = (options?: Options<UsersControllerFindAllData>) => {
    return infiniteQueryOptions<UsersControllerFindAllResponse, UsersControllerFindAllError, InfiniteData<UsersControllerFindAllResponse>, QueryKey<Options<UsersControllerFindAllData>>, number | Pick<QueryKey<Options<UsersControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<UsersControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await usersControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerFindAllInfiniteQueryKey(options)
    });
};

export const usersControllerCreateQueryKey = (options: Options<UsersControllerCreateData>) => createQueryKey('usersControllerCreate', options);

/**
 * Create a new user
 * This operation creates both a user and a supabase auth account
 */
export const usersControllerCreateOptions = (options: Options<UsersControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerCreateQueryKey(options)
    });
};

/**
 * Create a new user
 * This operation creates both a user and a supabase auth account
 */
export const usersControllerCreateMutation = (options?: Partial<Options<UsersControllerCreateData>>): UseMutationOptions<UsersControllerCreateResponse, UsersControllerCreateError, Options<UsersControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerCreateResponse, UsersControllerCreateError, Options<UsersControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerCreateStudentQueryKey = (options: Options<UsersControllerCreateStudentData>) => createQueryKey('usersControllerCreateStudent', options);

/**
 * Create a new student user
 * This operation creates both a user and a supabase auth account.
 * It also has additional properties for student-specific details.
 */
export const usersControllerCreateStudentOptions = (options: Options<UsersControllerCreateStudentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerCreateStudent({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerCreateStudentQueryKey(options)
    });
};

/**
 * Create a new student user
 * This operation creates both a user and a supabase auth account.
 * It also has additional properties for student-specific details.
 */
export const usersControllerCreateStudentMutation = (options?: Partial<Options<UsersControllerCreateStudentData>>): UseMutationOptions<UsersControllerCreateStudentResponse, UsersControllerCreateStudentError, Options<UsersControllerCreateStudentData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerCreateStudentResponse, UsersControllerCreateStudentError, Options<UsersControllerCreateStudentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerCreateStudent({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerCreateStaffQueryKey = (options: Options<UsersControllerCreateStaffData>) => createQueryKey('usersControllerCreateStaff', options);

/**
 * Create a new staff user
 * This operation creates both a user and a supabase auth account.
 * It also has additional properties for staff-specific details.
 */
export const usersControllerCreateStaffOptions = (options: Options<UsersControllerCreateStaffData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerCreateStaff({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerCreateStaffQueryKey(options)
    });
};

/**
 * Create a new staff user
 * This operation creates both a user and a supabase auth account.
 * It also has additional properties for staff-specific details.
 */
export const usersControllerCreateStaffMutation = (options?: Partial<Options<UsersControllerCreateStaffData>>): UseMutationOptions<UsersControllerCreateStaffResponse, UsersControllerCreateStaffError, Options<UsersControllerCreateStaffData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerCreateStaffResponse, UsersControllerCreateStaffError, Options<UsersControllerCreateStaffData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerCreateStaff({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerInviteUserQueryKey = (options: Options<UsersControllerInviteUserData>) => createQueryKey('usersControllerInviteUser', options);

/**
 * Invite a new user
 * This operation creates both a user and a supabase auth account
 */
export const usersControllerInviteUserOptions = (options: Options<UsersControllerInviteUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerInviteUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerInviteUserQueryKey(options)
    });
};

/**
 * Invite a new user
 * This operation creates both a user and a supabase auth account
 */
export const usersControllerInviteUserMutation = (options?: Partial<Options<UsersControllerInviteUserData>>): UseMutationOptions<UsersControllerInviteUserResponse, UsersControllerInviteUserError, Options<UsersControllerInviteUserData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerInviteUserResponse, UsersControllerInviteUserError, Options<UsersControllerInviteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerInviteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerGetMeQueryKey = (options?: Options<UsersControllerGetMeData>) => createQueryKey('usersControllerGetMe', options);

/**
 * Get the currently authenticated user
 * This endpoint returns the full profile of the currently authenticated user.
 * The structure of the returned object depends on the user's role:
 *
 * - `UserStudentDetailsDto` for users with the `student` role
 * - `UserStaffDetailsDto` for users with the `mentor` or `admin` role
 */
export const usersControllerGetMeOptions = (options?: Options<UsersControllerGetMeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerGetMe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerGetMeQueryKey(options)
    });
};

/**
 * Update personal details
 * This operation updates the user details in the database
 */
export const usersControllerUpdateOwnUserDetailsMutation = (options?: Partial<Options<UsersControllerUpdateOwnUserDetailsData>>): UseMutationOptions<UsersControllerUpdateOwnUserDetailsResponse, UsersControllerUpdateOwnUserDetailsError, Options<UsersControllerUpdateOwnUserDetailsData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerUpdateOwnUserDetailsResponse, UsersControllerUpdateOwnUserDetailsError, Options<UsersControllerUpdateOwnUserDetailsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerUpdateOwnUserDetails({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update student user details (Admin only)
 * This operation updates the user details in the database.
 * The user should have a student role.
 */
export const usersControllerUpdateUserStudentDetailsMutation = (options?: Partial<Options<UsersControllerUpdateUserStudentDetailsData>>): UseMutationOptions<UsersControllerUpdateUserStudentDetailsResponse, UsersControllerUpdateUserStudentDetailsError, Options<UsersControllerUpdateUserStudentDetailsData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerUpdateUserStudentDetailsResponse, UsersControllerUpdateUserStudentDetailsError, Options<UsersControllerUpdateUserStudentDetailsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerUpdateUserStudentDetails({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update staff user details (Admin only)
 * This operation updates the user details in the database.
 * The user should have a mentor or admin role.
 */
export const usersControllerUpdateUserStaffDetailsMutation = (options?: Partial<Options<UsersControllerUpdateUserStaffDetailsData>>): UseMutationOptions<UsersControllerUpdateUserStaffDetailsResponse, UsersControllerUpdateUserStaffDetailsError, Options<UsersControllerUpdateUserStaffDetailsData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerUpdateUserStaffDetailsResponse, UsersControllerUpdateUserStaffDetailsError, Options<UsersControllerUpdateUserStaffDetailsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerUpdateUserStaffDetails({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Deletes a user (soft and hard delete)
 * This endpoint performs either a soft delete or a permanent deletion of a user depending on the current state of the user or the query parameter provided:
 *
 * - If `directDelete` is true, the user is **permanently deleted** without checking if they are already softly deleted.
 * - If `directDelete` is not provided or false:
 * - If the user is not yet softly deleted (`deletedAt` is null), a **soft delete** is performed by setting the `deletedAt` timestamp.
 * - If the user is already softly deleted, a **permanent delete** is executed.
 *
 * All the user details and the supabase auth account will be deleted from the cloud on hard delete
 *
 * Use this endpoint to manage user deletion workflows flexibly through a single API.
 */
export const usersControllerRemoveMutation = (options?: Partial<Options<UsersControllerRemoveData>>): UseMutationOptions<UsersControllerRemoveResponse, UsersControllerRemoveError, Options<UsersControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerRemoveResponse, UsersControllerRemoveError, Options<UsersControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const usersControllerFindOneQueryKey = (options?: Options<UsersControllerFindOneData>) => createQueryKey('usersControllerFindOne', options);

/**
 * Get user by id
 * Retrieves a specific user by their unique identifier.
 * - **Validation: ** Ensures the provided `id` is a valid identifier format.
 * - **Not Found Handling: ** Throws an error if no matching user is found.
 */
export const usersControllerFindOneOptions = (options?: Options<UsersControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await usersControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: usersControllerFindOneQueryKey(options)
    });
};

/**
 * Updates the status of a user (enable/disable).
 * This endpoint toggles the user's status between active and disabled
 * by updating the `disabledAt` field. The change is also reflected in
 * the authentication provider's metadata.
 */
export const usersControllerUpdateUserStatusMutation = (options?: Partial<Options<UsersControllerUpdateUserStatusData>>): UseMutationOptions<UsersControllerUpdateUserStatusResponse, UsersControllerUpdateUserStatusError, Options<UsersControllerUpdateUserStatusData>> => {
    const mutationOptions: UseMutationOptions<UsersControllerUpdateUserStatusResponse, UsersControllerUpdateUserStatusError, Options<UsersControllerUpdateUserStatusData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await usersControllerUpdateUserStatus({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const coursesControllerFindAllQueryKey = (options?: Options<CoursesControllerFindAllData>) => createQueryKey('coursesControllerFindAll', options);

/**
 * Retrive all courses
 * Retrives a paginated list of courses based on the provided filters.
 * Requires `ADMIN` role.
 */
export const coursesControllerFindAllOptions = (options?: Options<CoursesControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await coursesControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: coursesControllerFindAllQueryKey(options)
    });
};

export const coursesControllerFindAllInfiniteQueryKey = (options?: Options<CoursesControllerFindAllData>): QueryKey<Options<CoursesControllerFindAllData>> => createQueryKey('coursesControllerFindAll', options, true);

/**
 * Retrive all courses
 * Retrives a paginated list of courses based on the provided filters.
 * Requires `ADMIN` role.
 */
export const coursesControllerFindAllInfiniteOptions = (options?: Options<CoursesControllerFindAllData>) => {
    return infiniteQueryOptions<CoursesControllerFindAllResponse, CoursesControllerFindAllError, InfiniteData<CoursesControllerFindAllResponse>, QueryKey<Options<CoursesControllerFindAllData>>, number | Pick<QueryKey<Options<CoursesControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<CoursesControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await coursesControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: coursesControllerFindAllInfiniteQueryKey(options)
    });
};

export const coursesControllerCreateQueryKey = (options: Options<CoursesControllerCreateData>) => createQueryKey('coursesControllerCreate', options);

/**
 * Creates a course
 * This operations creates a new course.
 * Requires `ADMIN` role.
 */
export const coursesControllerCreateOptions = (options: Options<CoursesControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await coursesControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: coursesControllerCreateQueryKey(options)
    });
};

/**
 * Creates a course
 * This operations creates a new course.
 * Requires `ADMIN` role.
 */
export const coursesControllerCreateMutation = (options?: Partial<Options<CoursesControllerCreateData>>): UseMutationOptions<CoursesControllerCreateResponse, CoursesControllerCreateError, Options<CoursesControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<CoursesControllerCreateResponse, CoursesControllerCreateError, Options<CoursesControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await coursesControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a course
 * This operation permanently deletes a course from the system.
 * Requires `ADMIN` role.
 */
export const coursesControllerRemoveMutation = (options?: Partial<Options<CoursesControllerRemoveData>>): UseMutationOptions<CoursesControllerRemoveResponse, CoursesControllerRemoveError, Options<CoursesControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<CoursesControllerRemoveResponse, CoursesControllerRemoveError, Options<CoursesControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await coursesControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const coursesControllerFindOneQueryKey = (options: Options<CoursesControllerFindOneData>) => createQueryKey('coursesControllerFindOne', options);

/**
 * Retrieve a specific course by ID
 * Requires `ADMIN` role.
 */
export const coursesControllerFindOneOptions = (options: Options<CoursesControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await coursesControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: coursesControllerFindOneQueryKey(options)
    });
};

/**
 * Update a course
 * This operation updates the details of an existing course.
 * Requires `ADMIN` role.
 */
export const coursesControllerUpdateMutation = (options?: Partial<Options<CoursesControllerUpdateData>>): UseMutationOptions<CoursesControllerUpdateResponse, CoursesControllerUpdateError, Options<CoursesControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<CoursesControllerUpdateResponse, CoursesControllerUpdateError, Options<CoursesControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await coursesControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const authControllerGetMetadataQueryKey = (options: Options<AuthControllerGetMetadataData>) => createQueryKey('authControllerGetMetadata', options);

/**
 * Get User Account Metadata
 * Retrieves the supabase auth account's metadata based on the uid given
 */
export const authControllerGetMetadataOptions = (options: Options<AuthControllerGetMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authControllerGetMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authControllerGetMetadataQueryKey(options)
    });
};

export const authControllerLoginQueryKey = (options: Options<AuthControllerLoginData>) => createQueryKey('authControllerLogin', options);

/**
 * Login Account
 * Login via email & password
 */
export const authControllerLoginOptions = (options: Options<AuthControllerLoginData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authControllerLogin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authControllerLoginQueryKey(options)
    });
};

/**
 * Login Account
 * Login via email & password
 */
export const authControllerLoginMutation = (options?: Partial<Options<AuthControllerLoginData>>): UseMutationOptions<AuthControllerLoginResponse, AuthControllerLoginError, Options<AuthControllerLoginData>> => {
    const mutationOptions: UseMutationOptions<AuthControllerLoginResponse, AuthControllerLoginError, Options<AuthControllerLoginData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await authControllerLogin({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const billingControllerFindAllQueryKey = (options?: Options<BillingControllerFindAllData>) => createQueryKey('billingControllerFindAll', options);

/**
 * Fetch bills
 * Fetch bills with the option to filter and sort them.
 * Contents of the returned list will depend on the user and their role.
 * Returns a paginated response.
 */
export const billingControllerFindAllOptions = (options?: Options<BillingControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await billingControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: billingControllerFindAllQueryKey(options)
    });
};

export const billingControllerFindAllInfiniteQueryKey = (options?: Options<BillingControllerFindAllData>): QueryKey<Options<BillingControllerFindAllData>> => createQueryKey('billingControllerFindAll', options, true);

/**
 * Fetch bills
 * Fetch bills with the option to filter and sort them.
 * Contents of the returned list will depend on the user and their role.
 * Returns a paginated response.
 */
export const billingControllerFindAllInfiniteOptions = (options?: Options<BillingControllerFindAllData>) => {
    return infiniteQueryOptions<BillingControllerFindAllResponse, BillingControllerFindAllError, InfiniteData<BillingControllerFindAllResponse>, QueryKey<Options<BillingControllerFindAllData>>, number | Pick<QueryKey<Options<BillingControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<BillingControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await billingControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: billingControllerFindAllInfiniteQueryKey(options)
    });
};

export const billingControllerCreateQueryKey = (options: Options<BillingControllerCreateData>) => createQueryKey('billingControllerCreate', options);

/**
 * Create a new bill
 * Creates a new bill item and can optionally attach a user
 */
export const billingControllerCreateOptions = (options: Options<BillingControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await billingControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: billingControllerCreateQueryKey(options)
    });
};

/**
 * Create a new bill
 * Creates a new bill item and can optionally attach a user
 */
export const billingControllerCreateMutation = (options?: Partial<Options<BillingControllerCreateData>>): UseMutationOptions<BillingControllerCreateResponse, BillingControllerCreateError, Options<BillingControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<BillingControllerCreateResponse, BillingControllerCreateError, Options<BillingControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await billingControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Deletes a bill (temporary or permanent)
 * This endpoint performs either a soft delete or a permanent deletion of a bill depending on the current state of the nill or the query parameter provided:
 *
 * - If `directDelete` is true, the bill is **permanently deleted** without checking if they are already softly deleted.
 * - If `directDelete` is not provided or false:
 * - If the bill is not yet softly deleted (`deletedAt` is null), a **soft delete** is performed by setting the `deletedAt` timestamp.
 * - If the bill is already softly deleted, a **permanent delete** is executed.
 */
export const billingControllerRemoveMutation = (options?: Partial<Options<BillingControllerRemoveData>>): UseMutationOptions<unknown, BillingControllerRemoveError, Options<BillingControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, BillingControllerRemoveError, Options<BillingControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await billingControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const billingControllerFindOneQueryKey = (options: Options<BillingControllerFindOneData>) => createQueryKey('billingControllerFindOne', options);

/**
 * Fetch a single bill
 * If the user is not an admin, they are only limited to querying their own bills.
 */
export const billingControllerFindOneOptions = (options: Options<BillingControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await billingControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: billingControllerFindOneQueryKey(options)
    });
};

/**
 * Update bill data
 * Change the bill's details
 */
export const billingControllerUpdateMutation = (options?: Partial<Options<BillingControllerUpdateData>>): UseMutationOptions<BillingControllerUpdateResponse, BillingControllerUpdateError, Options<BillingControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<BillingControllerUpdateResponse, BillingControllerUpdateError, Options<BillingControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await billingControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const installmentControllerFindAllQueryKey = (options: Options<InstallmentControllerFindAllData>) => createQueryKey('installmentControllerFindAll', options);

/**
 * Fetch installments
 * Fetch installments ordered by descending createdAt date
 * Contents of the returned list will depend on the user and their role.
 * Returns a paginated response.
 */
export const installmentControllerFindAllOptions = (options: Options<InstallmentControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await installmentControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: installmentControllerFindAllQueryKey(options)
    });
};

export const installmentControllerFindOneQueryKey = (options: Options<InstallmentControllerFindOneData>) => createQueryKey('installmentControllerFindOne', options);

/**
 * Fetch a single installment
 * If the user is not an admin, they are only limited to querying their own installments.
 */
export const installmentControllerFindOneOptions = (options: Options<InstallmentControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await installmentControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: installmentControllerFindOneQueryKey(options)
    });
};

export const paymentsControllerPayQueryKey = (options: Options<PaymentsControllerPayData>) => createQueryKey('paymentsControllerPay', options);

/**
 * Initiate paymongo payment intent
 * Handles the payment intent and payment gateway redirect of paymongo
 */
export const paymentsControllerPayOptions = (options: Options<PaymentsControllerPayData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await paymentsControllerPay({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: paymentsControllerPayQueryKey(options)
    });
};

/**
 * Initiate paymongo payment intent
 * Handles the payment intent and payment gateway redirect of paymongo
 */
export const paymentsControllerPayMutation = (options?: Partial<Options<PaymentsControllerPayData>>): UseMutationOptions<PaymentsControllerPayResponse, PaymentsControllerPayError, Options<PaymentsControllerPayData>> => {
    const mutationOptions: UseMutationOptions<PaymentsControllerPayResponse, PaymentsControllerPayError, Options<PaymentsControllerPayData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await paymentsControllerPay({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const paymentsControllerFindAllQueryKey = (options: Options<PaymentsControllerFindAllData>) => createQueryKey('paymentsControllerFindAll', options);

/**
 * Fetch payments
 * Fetch payments ordered by descending payment date
 * Contents of the returned list will depend on the user and their role.
 * Returns a paginated response.
 */
export const paymentsControllerFindAllOptions = (options: Options<PaymentsControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await paymentsControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: paymentsControllerFindAllQueryKey(options)
    });
};

export const paymentsControllerCreateQueryKey = (options: Options<PaymentsControllerCreateData>) => createQueryKey('paymentsControllerCreate', options);

/**
 * Create a new payment
 * Creates a new payment item
 */
export const paymentsControllerCreateOptions = (options: Options<PaymentsControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await paymentsControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: paymentsControllerCreateQueryKey(options)
    });
};

/**
 * Create a new payment
 * Creates a new payment item
 */
export const paymentsControllerCreateMutation = (options?: Partial<Options<PaymentsControllerCreateData>>): UseMutationOptions<PaymentsControllerCreateResponse, PaymentsControllerCreateError, Options<PaymentsControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<PaymentsControllerCreateResponse, PaymentsControllerCreateError, Options<PaymentsControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await paymentsControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Deletes a payment (temporary or permanent)
 * This endpoint performs either a soft delete or a permanent deletion of a payment depending on the current state of the nill or the query parameter provided:
 *
 * - If `directDelete` is true, the payment is **permanently deleted** without checking if they are already softly deleted.
 * - If `directDelete` is not provided or false:
 * - If the payment is not yet softly deleted (`deletedAt` is null), a **soft delete** is performed by setting the `deletedAt` timestamp.
 * - If the payment is already softly deleted, a **permanent delete** is executed.
 */
export const paymentsControllerRemoveMutation = (options?: Partial<Options<PaymentsControllerRemoveData>>): UseMutationOptions<unknown, PaymentsControllerRemoveError, Options<PaymentsControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, PaymentsControllerRemoveError, Options<PaymentsControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await paymentsControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const paymentsControllerFindOneQueryKey = (options: Options<PaymentsControllerFindOneData>) => createQueryKey('paymentsControllerFindOne', options);

/**
 * Fetch a single payment
 * If the user is not an admin, they are only limited to querying their own payments.
 */
export const paymentsControllerFindOneOptions = (options: Options<PaymentsControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await paymentsControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: paymentsControllerFindOneQueryKey(options)
    });
};

/**
 * Update payment data
 * Change the payment's details
 */
export const paymentsControllerUpdateMutation = (options?: Partial<Options<PaymentsControllerUpdateData>>): UseMutationOptions<PaymentsControllerUpdateResponse, PaymentsControllerUpdateError, Options<PaymentsControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<PaymentsControllerUpdateResponse, PaymentsControllerUpdateError, Options<PaymentsControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await paymentsControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const programControllerFindAllQueryKey = (options?: Options<ProgramControllerFindAllData>) => createQueryKey('programControllerFindAll', options);

/**
 * Retrieve all programs
 * Retrieves a paginated list of programs based on the provided filters.
 * Requires `ADMIN` role.
 */
export const programControllerFindAllOptions = (options?: Options<ProgramControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: programControllerFindAllQueryKey(options)
    });
};

export const programControllerFindAllInfiniteQueryKey = (options?: Options<ProgramControllerFindAllData>): QueryKey<Options<ProgramControllerFindAllData>> => createQueryKey('programControllerFindAll', options, true);

/**
 * Retrieve all programs
 * Retrieves a paginated list of programs based on the provided filters.
 * Requires `ADMIN` role.
 */
export const programControllerFindAllInfiniteOptions = (options?: Options<ProgramControllerFindAllData>) => {
    return infiniteQueryOptions<ProgramControllerFindAllResponse, ProgramControllerFindAllError, InfiniteData<ProgramControllerFindAllResponse>, QueryKey<Options<ProgramControllerFindAllData>>, number | Pick<QueryKey<Options<ProgramControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ProgramControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await programControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: programControllerFindAllInfiniteQueryKey(options)
    });
};

export const programControllerCreateQueryKey = (options: Options<ProgramControllerCreateData>) => createQueryKey('programControllerCreate', options);

/**
 * Create a new program
 * This operation creates a new academic program.
 * Requires `ADMIN` role.
 */
export const programControllerCreateOptions = (options: Options<ProgramControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: programControllerCreateQueryKey(options)
    });
};

/**
 * Create a new program
 * This operation creates a new academic program.
 * Requires `ADMIN` role.
 */
export const programControllerCreateMutation = (options?: Partial<Options<ProgramControllerCreateData>>): UseMutationOptions<ProgramControllerCreateResponse, ProgramControllerCreateError, Options<ProgramControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<ProgramControllerCreateResponse, ProgramControllerCreateError, Options<ProgramControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await programControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const programControllerFindAllMajorsQueryKey = (options: Options<ProgramControllerFindAllMajorsData>) => createQueryKey('programControllerFindAllMajors', options);

/**
 * Retrive all majors of a program
 * Retrives a paginated list of majors based on the program id and provided filters.
 * Requires `ADMIN` role.
 */
export const programControllerFindAllMajorsOptions = (options: Options<ProgramControllerFindAllMajorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programControllerFindAllMajors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: programControllerFindAllMajorsQueryKey(options)
    });
};

export const programControllerFindAllMajorsInfiniteQueryKey = (options: Options<ProgramControllerFindAllMajorsData>): QueryKey<Options<ProgramControllerFindAllMajorsData>> => createQueryKey('programControllerFindAllMajors', options, true);

/**
 * Retrive all majors of a program
 * Retrives a paginated list of majors based on the program id and provided filters.
 * Requires `ADMIN` role.
 */
export const programControllerFindAllMajorsInfiniteOptions = (options: Options<ProgramControllerFindAllMajorsData>) => {
    return infiniteQueryOptions<ProgramControllerFindAllMajorsResponse, ProgramControllerFindAllMajorsError, InfiniteData<ProgramControllerFindAllMajorsResponse>, QueryKey<Options<ProgramControllerFindAllMajorsData>>, number | Pick<QueryKey<Options<ProgramControllerFindAllMajorsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ProgramControllerFindAllMajorsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await programControllerFindAllMajors({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: programControllerFindAllMajorsInfiniteQueryKey(options)
    });
};

/**
 * Delete a program
 * This operation permanently deletes a program from the system.
 * Requires `ADMIN` role.
 */
export const programControllerRemoveMutation = (options?: Partial<Options<ProgramControllerRemoveData>>): UseMutationOptions<ProgramControllerRemoveResponse, ProgramControllerRemoveError, Options<ProgramControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<ProgramControllerRemoveResponse, ProgramControllerRemoveError, Options<ProgramControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await programControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const programControllerFindOneQueryKey = (options: Options<ProgramControllerFindOneData>) => createQueryKey('programControllerFindOne', options);

/**
 * Retrieve a specific program by ID
 * Requires `ADMIN` role.
 */
export const programControllerFindOneOptions = (options: Options<ProgramControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await programControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: programControllerFindOneQueryKey(options)
    });
};

/**
 * Update a program
 * This operation updates the details of an existing program.
 * Requires `ADMIN` role.
 */
export const programControllerUpdateMutation = (options?: Partial<Options<ProgramControllerUpdateData>>): UseMutationOptions<ProgramControllerUpdateResponse, ProgramControllerUpdateError, Options<ProgramControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<ProgramControllerUpdateResponse, ProgramControllerUpdateError, Options<ProgramControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await programControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const chatbotControllerPromptQueryKey = (options: Options<ChatbotControllerPromptData>) => createQueryKey('chatbotControllerPrompt', options);

export const chatbotControllerPromptOptions = (options: Options<ChatbotControllerPromptData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await chatbotControllerPrompt({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: chatbotControllerPromptQueryKey(options)
    });
};

export const chatbotControllerPromptMutation = (options?: Partial<Options<ChatbotControllerPromptData>>): UseMutationOptions<ChatbotControllerPromptResponse, ChatbotControllerPromptError, Options<ChatbotControllerPromptData>> => {
    const mutationOptions: UseMutationOptions<ChatbotControllerPromptResponse, ChatbotControllerPromptError, Options<ChatbotControllerPromptData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await chatbotControllerPrompt({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const majorControllerFindAllQueryKey = (options?: Options<MajorControllerFindAllData>) => createQueryKey('majorControllerFindAll', options);

/**
 * Retrive all majors
 * Retrives a paginated list of majors based on the provided filters.
 * Requires `ADMIN` role.
 */
export const majorControllerFindAllOptions = (options?: Options<MajorControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await majorControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: majorControllerFindAllQueryKey(options)
    });
};

export const majorControllerFindAllInfiniteQueryKey = (options?: Options<MajorControllerFindAllData>): QueryKey<Options<MajorControllerFindAllData>> => createQueryKey('majorControllerFindAll', options, true);

/**
 * Retrive all majors
 * Retrives a paginated list of majors based on the provided filters.
 * Requires `ADMIN` role.
 */
export const majorControllerFindAllInfiniteOptions = (options?: Options<MajorControllerFindAllData>) => {
    return infiniteQueryOptions<MajorControllerFindAllResponse, MajorControllerFindAllError, InfiniteData<MajorControllerFindAllResponse>, QueryKey<Options<MajorControllerFindAllData>>, number | Pick<QueryKey<Options<MajorControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<MajorControllerFindAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await majorControllerFindAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: majorControllerFindAllInfiniteQueryKey(options)
    });
};

export const majorControllerCreateQueryKey = (options: Options<MajorControllerCreateData>) => createQueryKey('majorControllerCreate', options);

/**
 * Creates a major.
 * This operation creates a new academic major.
 * Requries `ADMIN` role.
 */
export const majorControllerCreateOptions = (options: Options<MajorControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await majorControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: majorControllerCreateQueryKey(options)
    });
};

/**
 * Creates a major.
 * This operation creates a new academic major.
 * Requries `ADMIN` role.
 */
export const majorControllerCreateMutation = (options?: Partial<Options<MajorControllerCreateData>>): UseMutationOptions<MajorControllerCreateResponse, MajorControllerCreateError, Options<MajorControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<MajorControllerCreateResponse, MajorControllerCreateError, Options<MajorControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await majorControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a major
 * This operation permanently deletes a major from the system.
 * Requires `ADMIN` role.
 */
export const majorControllerRemoveMutation = (options?: Partial<Options<MajorControllerRemoveData>>): UseMutationOptions<MajorControllerRemoveResponse, MajorControllerRemoveError, Options<MajorControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<MajorControllerRemoveResponse, MajorControllerRemoveError, Options<MajorControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await majorControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const majorControllerFindOneQueryKey = (options: Options<MajorControllerFindOneData>) => createQueryKey('majorControllerFindOne', options);

/**
 * Retrieve a specific major by ID
 * Requires `ADMIN` role.
 */
export const majorControllerFindOneOptions = (options: Options<MajorControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await majorControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: majorControllerFindOneQueryKey(options)
    });
};

/**
 * Update a major
 * This operation updates the details of an existing major.
 * Requires `ADMIN` role.
 */
export const majorControllerUpdateMutation = (options?: Partial<Options<MajorControllerUpdateData>>): UseMutationOptions<MajorControllerUpdateResponse, MajorControllerUpdateError, Options<MajorControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<MajorControllerUpdateResponse, MajorControllerUpdateError, Options<MajorControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await majorControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enrollmentControllerFindAllEnrollmentsQueryKey = (options?: Options<EnrollmentControllerFindAllEnrollmentsData>) => createQueryKey('enrollmentControllerFindAllEnrollments', options);

/**
 * Retrieves all enrollment periods
 * Fetches a paginated list of enrollment periods.
 * Requires `ADMIN` role.
 */
export const enrollmentControllerFindAllEnrollmentsOptions = (options?: Options<EnrollmentControllerFindAllEnrollmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerFindAllEnrollments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerFindAllEnrollmentsQueryKey(options)
    });
};

export const enrollmentControllerFindAllEnrollmentsInfiniteQueryKey = (options?: Options<EnrollmentControllerFindAllEnrollmentsData>): QueryKey<Options<EnrollmentControllerFindAllEnrollmentsData>> => createQueryKey('enrollmentControllerFindAllEnrollments', options, true);

/**
 * Retrieves all enrollment periods
 * Fetches a paginated list of enrollment periods.
 * Requires `ADMIN` role.
 */
export const enrollmentControllerFindAllEnrollmentsInfiniteOptions = (options?: Options<EnrollmentControllerFindAllEnrollmentsData>) => {
    return infiniteQueryOptions<EnrollmentControllerFindAllEnrollmentsResponse, EnrollmentControllerFindAllEnrollmentsError, InfiniteData<EnrollmentControllerFindAllEnrollmentsResponse>, QueryKey<Options<EnrollmentControllerFindAllEnrollmentsData>>, number | Pick<QueryKey<Options<EnrollmentControllerFindAllEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<EnrollmentControllerFindAllEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await enrollmentControllerFindAllEnrollments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerFindAllEnrollmentsInfiniteQueryKey(options)
    });
};

export const enrollmentControllerCreateEnrollmentQueryKey = (options: Options<EnrollmentControllerCreateEnrollmentData>) => createQueryKey('enrollmentControllerCreateEnrollment', options);

/**
 * Creates a new enrollment period
 * This operation creates a new enrollment period for managing course registrations.
 * Requires `ADMIN` role.
 */
export const enrollmentControllerCreateEnrollmentOptions = (options: Options<EnrollmentControllerCreateEnrollmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerCreateEnrollment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerCreateEnrollmentQueryKey(options)
    });
};

/**
 * Creates a new enrollment period
 * This operation creates a new enrollment period for managing course registrations.
 * Requires `ADMIN` role.
 */
export const enrollmentControllerCreateEnrollmentMutation = (options?: Partial<Options<EnrollmentControllerCreateEnrollmentData>>): UseMutationOptions<EnrollmentControllerCreateEnrollmentResponse, EnrollmentControllerCreateEnrollmentError, Options<EnrollmentControllerCreateEnrollmentData>> => {
    const mutationOptions: UseMutationOptions<EnrollmentControllerCreateEnrollmentResponse, EnrollmentControllerCreateEnrollmentError, Options<EnrollmentControllerCreateEnrollmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enrollmentControllerCreateEnrollment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enrollmentControllerFindActiveEnrollmentQueryKey = (options?: Options<EnrollmentControllerFindActiveEnrollmentData>) => createQueryKey('enrollmentControllerFindActiveEnrollment', options);

/**
 * Retrieves the currently active enrollment period
 * Requires `ADMIN` or `STUDENT` roles.
 */
export const enrollmentControllerFindActiveEnrollmentOptions = (options?: Options<EnrollmentControllerFindActiveEnrollmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerFindActiveEnrollment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerFindActiveEnrollmentQueryKey(options)
    });
};

/**
 * Removes (soft or hard deletes) an enrollment period
 * Requires `ADMIN` role.
 */
export const enrollmentControllerRemoveEnrollmentMutation = (options?: Partial<Options<EnrollmentControllerRemoveEnrollmentData>>): UseMutationOptions<EnrollmentControllerRemoveEnrollmentResponse, EnrollmentControllerRemoveEnrollmentError, Options<EnrollmentControllerRemoveEnrollmentData>> => {
    const mutationOptions: UseMutationOptions<EnrollmentControllerRemoveEnrollmentResponse, EnrollmentControllerRemoveEnrollmentError, Options<EnrollmentControllerRemoveEnrollmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enrollmentControllerRemoveEnrollment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enrollmentControllerFindOneEnrollmentQueryKey = (options: Options<EnrollmentControllerFindOneEnrollmentData>) => createQueryKey('enrollmentControllerFindOneEnrollment', options);

/**
 * Retrieves a specific enrollment period by ID
 * Requires `ADMIN` role.
 */
export const enrollmentControllerFindOneEnrollmentOptions = (options: Options<EnrollmentControllerFindOneEnrollmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerFindOneEnrollment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerFindOneEnrollmentQueryKey(options)
    });
};

/**
 * Updates an enrollment period
 * Requires `ADMIN` role.
 */
export const enrollmentControllerUpdateEnrollmentMutation = (options?: Partial<Options<EnrollmentControllerUpdateEnrollmentData>>): UseMutationOptions<EnrollmentControllerUpdateEnrollmentResponse, EnrollmentControllerUpdateEnrollmentError, Options<EnrollmentControllerUpdateEnrollmentData>> => {
    const mutationOptions: UseMutationOptions<EnrollmentControllerUpdateEnrollmentResponse, EnrollmentControllerUpdateEnrollmentError, Options<EnrollmentControllerUpdateEnrollmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enrollmentControllerUpdateEnrollment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Updates the status of an enrollment period
 * Requires `ADMIN` role.
 */
export const enrollmentControllerUpdateEnrollmentStatusMutation = (options?: Partial<Options<EnrollmentControllerUpdateEnrollmentStatusData>>): UseMutationOptions<EnrollmentControllerUpdateEnrollmentStatusResponse, EnrollmentControllerUpdateEnrollmentStatusError, Options<EnrollmentControllerUpdateEnrollmentStatusData>> => {
    const mutationOptions: UseMutationOptions<EnrollmentControllerUpdateEnrollmentStatusResponse, EnrollmentControllerUpdateEnrollmentStatusError, Options<EnrollmentControllerUpdateEnrollmentStatusData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enrollmentControllerUpdateEnrollmentStatus({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseOfferingControllerFindCourseOfferingsByPeriodQueryKey = (options: Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>) => createQueryKey('courseOfferingControllerFindCourseOfferingsByPeriod', options);

/**
 * Retrieves all course offerings in a specific enrollment period
 * Fetches a paginated list of course offerings for the given period.
 * Requires `ADMIN` or `STUDENT` role.
 */
export const courseOfferingControllerFindCourseOfferingsByPeriodOptions = (options: Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseOfferingControllerFindCourseOfferingsByPeriod({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseOfferingControllerFindCourseOfferingsByPeriodQueryKey(options)
    });
};

export const courseOfferingControllerFindCourseOfferingsByPeriodInfiniteQueryKey = (options: Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>): QueryKey<Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>> => createQueryKey('courseOfferingControllerFindCourseOfferingsByPeriod', options, true);

/**
 * Retrieves all course offerings in a specific enrollment period
 * Fetches a paginated list of course offerings for the given period.
 * Requires `ADMIN` or `STUDENT` role.
 */
export const courseOfferingControllerFindCourseOfferingsByPeriodInfiniteOptions = (options: Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>) => {
    return infiniteQueryOptions<CourseOfferingControllerFindCourseOfferingsByPeriodResponse, DefaultError, InfiniteData<CourseOfferingControllerFindCourseOfferingsByPeriodResponse>, QueryKey<Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>>, number | Pick<QueryKey<Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<CourseOfferingControllerFindCourseOfferingsByPeriodData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await courseOfferingControllerFindCourseOfferingsByPeriod({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseOfferingControllerFindCourseOfferingsByPeriodInfiniteQueryKey(options)
    });
};

export const courseOfferingControllerCreateCourseOfferingQueryKey = (options: Options<CourseOfferingControllerCreateCourseOfferingData>) => createQueryKey('courseOfferingControllerCreateCourseOffering', options);

/**
 * Creates a new course offering under a specific enrollment period
 * Requires `ADMIN` role.
 */
export const courseOfferingControllerCreateCourseOfferingOptions = (options: Options<CourseOfferingControllerCreateCourseOfferingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseOfferingControllerCreateCourseOffering({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseOfferingControllerCreateCourseOfferingQueryKey(options)
    });
};

/**
 * Creates a new course offering under a specific enrollment period
 * Requires `ADMIN` role.
 */
export const courseOfferingControllerCreateCourseOfferingMutation = (options?: Partial<Options<CourseOfferingControllerCreateCourseOfferingData>>): UseMutationOptions<CourseOfferingControllerCreateCourseOfferingResponse, CourseOfferingControllerCreateCourseOfferingError, Options<CourseOfferingControllerCreateCourseOfferingData>> => {
    const mutationOptions: UseMutationOptions<CourseOfferingControllerCreateCourseOfferingResponse, CourseOfferingControllerCreateCourseOfferingError, Options<CourseOfferingControllerCreateCourseOfferingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseOfferingControllerCreateCourseOffering({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Removes a course offering from a specific enrollment period
 * Requires `ADMIN` role.
 */
export const courseOfferingControllerRemoveCourseOfferingMutation = (options?: Partial<Options<CourseOfferingControllerRemoveCourseOfferingData>>): UseMutationOptions<CourseOfferingControllerRemoveCourseOfferingResponse, CourseOfferingControllerRemoveCourseOfferingError, Options<CourseOfferingControllerRemoveCourseOfferingData>> => {
    const mutationOptions: UseMutationOptions<CourseOfferingControllerRemoveCourseOfferingResponse, CourseOfferingControllerRemoveCourseOfferingError, Options<CourseOfferingControllerRemoveCourseOfferingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseOfferingControllerRemoveCourseOffering({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseOfferingControllerFindOneCourseOfferingQueryKey = (options: Options<CourseOfferingControllerFindOneCourseOfferingData>) => createQueryKey('courseOfferingControllerFindOneCourseOffering', options);

/**
 * Retrieves a specific course offering by ID
 * Requires `ADMIN` role.
 */
export const courseOfferingControllerFindOneCourseOfferingOptions = (options: Options<CourseOfferingControllerFindOneCourseOfferingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseOfferingControllerFindOneCourseOffering({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseOfferingControllerFindOneCourseOfferingQueryKey(options)
    });
};

export const courseSectionControllerFindAllCourseSectionsQueryKey = (options: Options<CourseSectionControllerFindAllCourseSectionsData>) => createQueryKey('courseSectionControllerFindAllCourseSections', options);

/**
 * Retrieves all sections for a specific enrollment period
 * Fetches a paginated list of course sections.
 * Requires `ADMIN` role.
 */
export const courseSectionControllerFindAllCourseSectionsOptions = (options: Options<CourseSectionControllerFindAllCourseSectionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseSectionControllerFindAllCourseSections({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerFindAllCourseSectionsQueryKey(options)
    });
};

export const courseSectionControllerFindAllCourseSectionsInfiniteQueryKey = (options: Options<CourseSectionControllerFindAllCourseSectionsData>): QueryKey<Options<CourseSectionControllerFindAllCourseSectionsData>> => createQueryKey('courseSectionControllerFindAllCourseSections', options, true);

/**
 * Retrieves all sections for a specific enrollment period
 * Fetches a paginated list of course sections.
 * Requires `ADMIN` role.
 */
export const courseSectionControllerFindAllCourseSectionsInfiniteOptions = (options: Options<CourseSectionControllerFindAllCourseSectionsData>) => {
    return infiniteQueryOptions<CourseSectionControllerFindAllCourseSectionsResponse, CourseSectionControllerFindAllCourseSectionsError, InfiniteData<CourseSectionControllerFindAllCourseSectionsResponse>, QueryKey<Options<CourseSectionControllerFindAllCourseSectionsData>>, number | Pick<QueryKey<Options<CourseSectionControllerFindAllCourseSectionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<CourseSectionControllerFindAllCourseSectionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await courseSectionControllerFindAllCourseSections({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerFindAllCourseSectionsInfiniteQueryKey(options)
    });
};

export const courseSectionControllerFindAllCourseSectionsForOfferingQueryKey = (options: Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>) => createQueryKey('courseSectionControllerFindAllCourseSectionsForOffering', options);

/**
 * Retrieves all sections for a specific course offering
 * Fetches a paginated list of course sections.
 * Requires `ADMIN` role.
 */
export const courseSectionControllerFindAllCourseSectionsForOfferingOptions = (options: Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseSectionControllerFindAllCourseSectionsForOffering({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerFindAllCourseSectionsForOfferingQueryKey(options)
    });
};

export const courseSectionControllerFindAllCourseSectionsForOfferingInfiniteQueryKey = (options: Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>): QueryKey<Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>> => createQueryKey('courseSectionControllerFindAllCourseSectionsForOffering', options, true);

/**
 * Retrieves all sections for a specific course offering
 * Fetches a paginated list of course sections.
 * Requires `ADMIN` role.
 */
export const courseSectionControllerFindAllCourseSectionsForOfferingInfiniteOptions = (options: Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>) => {
    return infiniteQueryOptions<CourseSectionControllerFindAllCourseSectionsForOfferingResponse, CourseSectionControllerFindAllCourseSectionsForOfferingError, InfiniteData<CourseSectionControllerFindAllCourseSectionsForOfferingResponse>, QueryKey<Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>>, number | Pick<QueryKey<Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<CourseSectionControllerFindAllCourseSectionsForOfferingData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await courseSectionControllerFindAllCourseSectionsForOffering({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerFindAllCourseSectionsForOfferingInfiniteQueryKey(options)
    });
};

export const courseSectionControllerCreateCourseSectionQueryKey = (options: Options<CourseSectionControllerCreateCourseSectionData>) => createQueryKey('courseSectionControllerCreateCourseSection', options);

/**
 * Creates a new course section under a specific course offering
 * Requires `ADMIN` role.
 */
export const courseSectionControllerCreateCourseSectionOptions = (options: Options<CourseSectionControllerCreateCourseSectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseSectionControllerCreateCourseSection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerCreateCourseSectionQueryKey(options)
    });
};

/**
 * Creates a new course section under a specific course offering
 * Requires `ADMIN` role.
 */
export const courseSectionControllerCreateCourseSectionMutation = (options?: Partial<Options<CourseSectionControllerCreateCourseSectionData>>): UseMutationOptions<CourseSectionControllerCreateCourseSectionResponse, CourseSectionControllerCreateCourseSectionError, Options<CourseSectionControllerCreateCourseSectionData>> => {
    const mutationOptions: UseMutationOptions<CourseSectionControllerCreateCourseSectionResponse, CourseSectionControllerCreateCourseSectionError, Options<CourseSectionControllerCreateCourseSectionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseSectionControllerCreateCourseSection({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Removes a course section from a specific course offering
 * Requires `ADMIN` role.
 */
export const courseSectionControllerRemoveCourseSectionMutation = (options?: Partial<Options<CourseSectionControllerRemoveCourseSectionData>>): UseMutationOptions<CourseSectionControllerRemoveCourseSectionResponse, CourseSectionControllerRemoveCourseSectionError, Options<CourseSectionControllerRemoveCourseSectionData>> => {
    const mutationOptions: UseMutationOptions<CourseSectionControllerRemoveCourseSectionResponse, CourseSectionControllerRemoveCourseSectionError, Options<CourseSectionControllerRemoveCourseSectionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseSectionControllerRemoveCourseSection({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseSectionControllerFindOneCourseSectionQueryKey = (options: Options<CourseSectionControllerFindOneCourseSectionData>) => createQueryKey('courseSectionControllerFindOneCourseSection', options);

/**
 * Retrieves a specific course section under a course offering
 * Requires `ADMIN` role.
 */
export const courseSectionControllerFindOneCourseSectionOptions = (options: Options<CourseSectionControllerFindOneCourseSectionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseSectionControllerFindOneCourseSection({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSectionControllerFindOneCourseSectionQueryKey(options)
    });
};

/**
 * Updates a course section under a specific course offering
 * Requires `ADMIN` role.
 */
export const courseSectionControllerUpdateCourseSectionMutation = (options?: Partial<Options<CourseSectionControllerUpdateCourseSectionData>>): UseMutationOptions<CourseSectionControllerUpdateCourseSectionResponse, CourseSectionControllerUpdateCourseSectionError, Options<CourseSectionControllerUpdateCourseSectionData>> => {
    const mutationOptions: UseMutationOptions<CourseSectionControllerUpdateCourseSectionResponse, CourseSectionControllerUpdateCourseSectionError, Options<CourseSectionControllerUpdateCourseSectionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseSectionControllerUpdateCourseSection({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseEnrollmentControllerGetCourseEnrollmentsQueryKey = (options?: Options<CourseEnrollmentControllerGetCourseEnrollmentsData>) => createQueryKey('courseEnrollmentControllerGetCourseEnrollments', options);

/**
 * Retrieve all active (enlisted) course enrollments for the authenticated user.
 * - `STUDENT` will receive their own enlisted enrollments for the active enrollment period.
 * - `ADMIN` may call this endpoint (typically for inspection); use DTO body to scope to another student when supported.
 * - Each returned record includes related course offering, course section and mentor/user data.
 */
export const courseEnrollmentControllerGetCourseEnrollmentsOptions = (options?: Options<CourseEnrollmentControllerGetCourseEnrollmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseEnrollmentControllerGetCourseEnrollments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseEnrollmentControllerGetCourseEnrollmentsQueryKey(options)
    });
};

/**
 * Retrieve all active (enlisted) course enrollments for the authenticated user.
 * - `STUDENT` will receive their own enlisted enrollments for the active enrollment period.
 * - `ADMIN` may call this endpoint (typically for inspection); use DTO body to scope to another student when supported.
 * - Each returned record includes related course offering, course section and mentor/user data.
 */
export const courseEnrollmentControllerGetCourseEnrollmentsMutation = (options?: Partial<Options<CourseEnrollmentControllerGetCourseEnrollmentsData>>): UseMutationOptions<CourseEnrollmentControllerGetCourseEnrollmentsResponse, CourseEnrollmentControllerGetCourseEnrollmentsError, Options<CourseEnrollmentControllerGetCourseEnrollmentsData>> => {
    const mutationOptions: UseMutationOptions<CourseEnrollmentControllerGetCourseEnrollmentsResponse, CourseEnrollmentControllerGetCourseEnrollmentsError, Options<CourseEnrollmentControllerGetCourseEnrollmentsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseEnrollmentControllerGetCourseEnrollments({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Drop a student from a course section.
 * - `STUDENT` can only drop themselves.
 * - `ADMIN` can drop on behalf of another student (using `studentId` in body).
 */
export const courseEnrollmentControllerDropCourseEnrollmentMutation = (options?: Partial<Options<CourseEnrollmentControllerDropCourseEnrollmentData>>): UseMutationOptions<CourseEnrollmentControllerDropCourseEnrollmentResponse, CourseEnrollmentControllerDropCourseEnrollmentError, Options<CourseEnrollmentControllerDropCourseEnrollmentData>> => {
    const mutationOptions: UseMutationOptions<CourseEnrollmentControllerDropCourseEnrollmentResponse, CourseEnrollmentControllerDropCourseEnrollmentError, Options<CourseEnrollmentControllerDropCourseEnrollmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseEnrollmentControllerDropCourseEnrollment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseEnrollmentControllerCreateCourseEnrollmentQueryKey = (options: Options<CourseEnrollmentControllerCreateCourseEnrollmentData>) => createQueryKey('courseEnrollmentControllerCreateCourseEnrollment', options);

/**
 * Enroll a student in a course section.
 * - `STUDENT` can only enroll themselves.
 * - `ADMIN` can enroll on behalf of another student (using `studentId` in body).
 */
export const courseEnrollmentControllerCreateCourseEnrollmentOptions = (options: Options<CourseEnrollmentControllerCreateCourseEnrollmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseEnrollmentControllerCreateCourseEnrollment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseEnrollmentControllerCreateCourseEnrollmentQueryKey(options)
    });
};

/**
 * Enroll a student in a course section.
 * - `STUDENT` can only enroll themselves.
 * - `ADMIN` can enroll on behalf of another student (using `studentId` in body).
 */
export const courseEnrollmentControllerCreateCourseEnrollmentMutation = (options?: Partial<Options<CourseEnrollmentControllerCreateCourseEnrollmentData>>): UseMutationOptions<CourseEnrollmentControllerCreateCourseEnrollmentResponse, CourseEnrollmentControllerCreateCourseEnrollmentError, Options<CourseEnrollmentControllerCreateCourseEnrollmentData>> => {
    const mutationOptions: UseMutationOptions<CourseEnrollmentControllerCreateCourseEnrollmentResponse, CourseEnrollmentControllerCreateCourseEnrollmentError, Options<CourseEnrollmentControllerCreateCourseEnrollmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseEnrollmentControllerCreateCourseEnrollment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseEnrollmentControllerFinalizeCourseEnrollmentQueryKey = (options?: Options<CourseEnrollmentControllerFinalizeCourseEnrollmentData>) => createQueryKey('courseEnrollmentControllerFinalizeCourseEnrollment', options);

/**
 * Finalize all course enrollments for a student.
 * - Sets all enrolled courses for the student to `finalized`.
 * - `STUDENT` can finalize only their own enrollments.
 * - `ADMIN` can finalize for any student by providing `studentId` in the request body.
 */
export const courseEnrollmentControllerFinalizeCourseEnrollmentOptions = (options?: Options<CourseEnrollmentControllerFinalizeCourseEnrollmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseEnrollmentControllerFinalizeCourseEnrollment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseEnrollmentControllerFinalizeCourseEnrollmentQueryKey(options)
    });
};

/**
 * Finalize all course enrollments for a student.
 * - Sets all enrolled courses for the student to `finalized`.
 * - `STUDENT` can finalize only their own enrollments.
 * - `ADMIN` can finalize for any student by providing `studentId` in the request body.
 */
export const courseEnrollmentControllerFinalizeCourseEnrollmentMutation = (options?: Partial<Options<CourseEnrollmentControllerFinalizeCourseEnrollmentData>>): UseMutationOptions<CourseEnrollmentControllerFinalizeCourseEnrollmentResponse, CourseEnrollmentControllerFinalizeCourseEnrollmentError, Options<CourseEnrollmentControllerFinalizeCourseEnrollmentData>> => {
    const mutationOptions: UseMutationOptions<CourseEnrollmentControllerFinalizeCourseEnrollmentResponse, CourseEnrollmentControllerFinalizeCourseEnrollmentError, Options<CourseEnrollmentControllerFinalizeCourseEnrollmentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseEnrollmentControllerFinalizeCourseEnrollment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const curriculumControllerFindAllQueryKey = (options?: Options<CurriculumControllerFindAllData>) => createQueryKey('curriculumControllerFindAll', options);

/**
 * Fetch curriculums
 * Fetches all of the curriculums
 * Returns a list
 */
export const curriculumControllerFindAllOptions = (options?: Options<CurriculumControllerFindAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await curriculumControllerFindAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: curriculumControllerFindAllQueryKey(options)
    });
};

export const curriculumControllerCreateQueryKey = (options: Options<CurriculumControllerCreateData>) => createQueryKey('curriculumControllerCreate', options);

/**
 * Create a new curriculum
 * Creates a new curriculum with attached course plan
 */
export const curriculumControllerCreateOptions = (options: Options<CurriculumControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await curriculumControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: curriculumControllerCreateQueryKey(options)
    });
};

/**
 * Create a new curriculum
 * Creates a new curriculum with attached course plan
 */
export const curriculumControllerCreateMutation = (options?: Partial<Options<CurriculumControllerCreateData>>): UseMutationOptions<CurriculumControllerCreateResponse, CurriculumControllerCreateError, Options<CurriculumControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<CurriculumControllerCreateResponse, CurriculumControllerCreateError, Options<CurriculumControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await curriculumControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Deletes a curriculum (temporary or permanent)
 * This endpoint performs either a soft delete or a permanent deletion of a curriculum depending on the current state of the nill or the query parameter provided:
 *
 * - If `directDelete` is true, the curriculum is **permanently deleted** without checking if they are already softly deleted.
 * - If `directDelete` is not provided or false:
 * - If the curriculum is not yet softly deleted (`deletedAt` is null), a **soft delete** is performed by setting the `deletedAt` timestamp.
 * - If the curriculum is already softly deleted, a **permanent delete** is executed.
 */
export const curriculumControllerRemoveMutation = (options?: Partial<Options<CurriculumControllerRemoveData>>): UseMutationOptions<unknown, CurriculumControllerRemoveError, Options<CurriculumControllerRemoveData>> => {
    const mutationOptions: UseMutationOptions<unknown, CurriculumControllerRemoveError, Options<CurriculumControllerRemoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await curriculumControllerRemove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const curriculumControllerFindOneQueryKey = (options: Options<CurriculumControllerFindOneData>) => createQueryKey('curriculumControllerFindOne', options);

/**
 * Fetch a single curriculum
 * Fetch the curriculum details and the courses attached to it
 */
export const curriculumControllerFindOneOptions = (options: Options<CurriculumControllerFindOneData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await curriculumControllerFindOne({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: curriculumControllerFindOneQueryKey(options)
    });
};

/**
 * Update curriculum
 * Updates an existing curriculum and course plan
 */
export const curriculumControllerUpdateMutation = (options?: Partial<Options<CurriculumControllerUpdateData>>): UseMutationOptions<CurriculumControllerUpdateResponse, CurriculumControllerUpdateError, Options<CurriculumControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<CurriculumControllerUpdateResponse, CurriculumControllerUpdateError, Options<CurriculumControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await curriculumControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const swaggerControllerDownloadAllSpecsQueryKey = (options?: Options<SwaggerControllerDownloadAllSpecsData>) => createQueryKey('swaggerControllerDownloadAllSpecs', options);

export const swaggerControllerDownloadAllSpecsOptions = (options?: Options<SwaggerControllerDownloadAllSpecsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await swaggerControllerDownloadAllSpecs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: swaggerControllerDownloadAllSpecsQueryKey(options)
    });
};