import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import { Buffer } from "node:buffer";
import crypto from "node:crypto";
import { PayMongoWebhookEvent } from "./paymongo-types.ts";
import { Database } from "../../database.types.ts";
import { BillPayment } from "./drizzle.schema.ts";
import Decimal from "jsr:@quentinadam/decimal";

const webhookSecret = Deno.env.get("PAYMONGO_WEBHOOK_SECRET")!;
const dbUrl = Deno.env.get("DB_POOL_URL")!;

Deno.serve(async (req) => {
  try {
    const body = (await req.json()) as PayMongoWebhookEvent;
    const signature = req.headers.get("paymongo-signature")!;

    const isValid = verifySignature(body, signature, webhookSecret);

    if (!isValid) {
      console.log("Invalid paymongo signature");
      return new Response(JSON.stringify({ received: true }));
    }

    const event = body.data;

    switch (event.attributes.type) {
      case "payment.paid": {
        const data = event.attributes.data.attributes;

        if (!data.metadata?.billingId) {
          console.log("Billid id in metadata is missing");
          return new Response(JSON.stringify({ received: true }));
        }

        const paymentType: Database["public"]["Enums"]["PaymentType"] =
          data.source ? data.source.type : "manual";

        const amountPaid = Decimal.from(data.amount);

        const client = postgres(dbUrl, { prepare: false });
        const db = drizzle(client);

        await db.insert(BillPayment).values({
          id: crypto.randomUUID(),
          billId: data.metadata.billingId,
          amountPaid: amountPaid.div(100).toFixed(2),
          notes: "Auto-generated by paymongo",
          paymentType: paymentType,
          paymongoData: body,
          paymentDate: new Date().toISOString(),
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        });

        console.log("SUCCESS!!!");
        break;
      }
      case "payment.failed": {
        console.log("FAILED!");
        break;
      }
      default: {
        console.log("DEFAULT!");
        break;
      }
    }

    return new Response(JSON.stringify({ received: true }));
  } catch (err) {
    console.log(err);
    return new Response(JSON.stringify({ received: true }));
  }
});

const verifySignature = (
  body: PayMongoWebhookEvent,
  signatureHeader: string,
  secret: string
): boolean => {
  try {
    const parts = signatureHeader
      .split(",")
      .reduce((acc: Record<PropertyKey, string>, part) => {
        const [key, value] = part.split("=");
        acc[key] = value;
        return acc;
      }, {});

    const timestamp = parts["t"];
    const testSig = parts["te"];
    const liveSig = parts["li"];

    if (!timestamp || (!testSig && !liveSig)) {
      console.error("Invalid PayMongo signature header format");
      return false;
    }

    const expectedSig = liveSig || testSig;

    // Use the original JSON string
    const rawJson = JSON.stringify(body);

    // Concatenate timestamp + "." + payload
    const signedPayload = `${timestamp}.${rawJson}`;

    // Compute the HMAC
    const computedSig = crypto
      .createHmac("sha256", secret)
      .update(signedPayload)
      .digest("hex");

    return crypto.timingSafeEqual(
      Buffer.from(expectedSig, "utf8"),
      Buffer.from(computedSig, "utf8")
    );
  } catch (err) {
    console.error(`Error verifying signature: ${err}`);
    return false;
  }
};
